{ "version": 3, "file": "java/ormery/src/main/java/ormery/Query.java", "sources": [ "-work/src/ormery.temper.md" ], "sourcesContent": [ "# ORMery - All-in-One Demo\n\nA simplified version of Ecto in Temper, using secure-composition for\ninjection-proof SQL generation.\n\n    let { sql, SqlFragment, SqlBuilder } = import(\u0022./sql\u0022);\n\n## Field and Schema\n\n    export class Field(\n      public name: String,\n      public fieldType: String,\n      public primaryKey: Boolean,\n      public nullable: Boolean,\n    ) {\n      public get description(): String {\n        let pk = if (primaryKey) { \u0022 (PK)\u0022 } else { \u0022\u0022 };\n        let null = if (nullable) { \u0022 (nullable)\u0022 } else { \u0022\u0022 };\n        \u0022\u0024{name}: \u0024{fieldType}\u0024{pk}\u0024{null}\u0022\n      }\n    }\n\n    export class Schema(\n      public tableName: String,\n      public fields: List\u003cField\u003e,\n    ) {\n      public getField(name: String): Field throws Bubble {\n        for (let field of fields) {\n          if (field.name == name) {\n            return field;\n          }\n        }\n        bubble()\n      }\n\n      public hasField(name: String): Boolean {\n        for (let field of fields) {\n          if (field.name == name) {\n            return true;\n          }\n        }\n        false\n      }\n\n      public get primaryKeyField(): Field throws Bubble {\n        for (let field of fields) {\n          if (field.primaryKey) {\n            return field;\n          }\n        }\n        bubble()\n      }\n\n      public get fieldNames(): List\u003cString\u003e {\n        fields.map { (f: Field): String =\u003e f.name }\n      }\n\n      public describe(): String {\n        let header = \u0022Schema: \u0024{tableName}\\n\u0022;\n        let fieldList = fields\n          .map { (f: Field): String =\u003e \u0022  - \u0024{f.description}\u0022 }\n          .join(\u0022\\n\u0022) { (s: String): String =\u003e s };\n        \u0022\u0024{header}\u0024{fieldList}\u0022\n      }\n    }\n\n    export let field(\n      name: String,\n      fieldType: String,\n      primaryKey: Boolean,\n      nullable: Boolean,\n    ): Field {\n      new Field(name, fieldType, primaryKey, nullable)\n    }\n\n### Identifier validation\n\nOnly allow safe SQL identifier characters: `a-z`, `A-Z`, `0-9`, `_`.\nThis closes the table name backdoor where `schema()` accepted arbitrary\nstrings that passed through `safeSql()` → `appendSafe()` unescaped.\n\n    export let isValidIdentifier(name: String): Boolean {\n      if (name.isEmpty) { return false; }\n      for (let c of name) {\n        if (c != char'_') {\n          if (c \u003e= char'a') {\n            if (c \u003e char'z') { return false; }\n          } else if (c \u003e= char'A') {\n            if (c \u003e char'Z') { return false; }\n          } else if (c \u003e= char'0') {\n            if (c \u003e char'9') { return false; }\n          } else {\n            return false;\n          }\n        }\n      }\n      true\n    }\n\n    export let schema(tableName: String, fields: List\u003cField\u003e): Schema {\n      if (!isValidIdentifier(tableName)) { panic(); }\n      let idField = new Field(\u0022id\u0022, \u0022Int\u0022, true, false);\n      let allFields = new ListBuilder\u003cField\u003e();\n      allFields.add(idField);\n      allFields.addAll(fields);\n      new Schema(tableName, allFields.toList())\n    }\n\n## Record and Store\n\n    export class Record(\n      public data: Map\u003cString, String\u003e,\n    ) {\n      public get(field: String): String throws Bubble {\n        data.get(field)\n      }\n\n      public getOr(field: String, fallback: String): String {\n        data.getOr(field, fallback)\n      }\n\n      public has(field: String): Boolean {\n        data.has(field)\n      }\n\n      public get id(): Int throws Bubble {\n        let idStr = data.get(\u0022id\u0022);\n        idStr.toInt32() orelse bubble()\n      }\n\n      public describe(): String {\n        let pairs = data.toListWith { (k: String, v: String): String =\u003e\n          \u0022\u0024{k}: \u0024{v}\u0022\n        };\n        pairs.join(\u0022, \u0022) { (s: String): String =\u003e s }\n      }\n    }\n\n    export class InMemoryStore() {\n      private var tables: MapBuilder\u003cString, ListBuilder\u003cRecord\u003e\u003e;\n      private var nextIds: MapBuilder\u003cString, Int\u003e;\n\n      public constructor() {\n        tables = new MapBuilder\u003cString, ListBuilder\u003cRecord\u003e\u003e();\n        nextIds = new MapBuilder\u003cString, Int\u003e();\n      }\n\n      private ensureTable(tableName: String): Void {\n        if (!tables.has(tableName)) {\n          tables.set(tableName, new ListBuilder\u003cRecord\u003e());\n          nextIds.set(tableName, 1);\n        }\n      }\n\n      public insert(tableName: String, data: Map\u003cString, String\u003e): Record {\n        ensureTable(tableName);\n        let id = nextIds.getOr(tableName, 1);\n        nextIds.set(tableName, id + 1);\n\n        let dataBuilder = data.toMapBuilder();\n        dataBuilder.set(\u0022id\u0022, id.toString());\n        let record = new Record(dataBuilder.toMap());\n\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.add(record);\n        record\n      }\n\n      public all(tableName: String): List\u003cRecord\u003e {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.toList()\n      }\n\n      public get(tableName: String, id: Int): Record throws Bubble {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n\n        for (let record of table.toList()) {\n          let recordId = record.id orelse bubble();\n          if (recordId == id) {\n            return record;\n          }\n        }\n        bubble()\n      }\n\n      public count(tableName: String): Int {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.length\n      }\n    }\n\n## Query Builder\n\n    export class WhereClause(\n      public field: String,\n      public operator: String,\n      public value: String,\n    ) {\n      public describe(): String {\n        \u0022\u0024{field} \u0024{operator} \u0024{value}\u0022\n      }\n    }\n\n    export class OrderClause(\n      public field: String,\n      public direction: String,\n    ) {\n      public describe(): String {\n        \u0022\u0024{field} \u0024{direction}\u0022\n      }\n    }\n\n    export class Query(\n      public schema: Schema,\n      public store: InMemoryStore,\n    ) {\n      private var whereClauses: ListBuilder\u003cWhereClause\u003e;\n      private var selectFields: List\u003cString\u003e;\n      private var orderByClauses: ListBuilder\u003cOrderClause\u003e;\n      private var limitValue: Int;\n      private var offsetValue: Int;\n\n      public constructor(schema: Schema, store: InMemoryStore) {\n        this.schema = schema;\n        this.store = store;\n        whereClauses = new ListBuilder\u003cWhereClause\u003e();\n        selectFields = [];\n        orderByClauses = new ListBuilder\u003cOrderClause\u003e();\n        limitValue = -1;\n        offsetValue = 0;\n      }\n\n      public where(field: String, operator: String, value: String): Query {\n        whereClauses.add(new WhereClause(field, operator, value));\n        this\n      }\n\n      public select(fields: List\u003cString\u003e): Query {\n        selectFields = fields;\n        this\n      }\n\n      public orderBy(field: String, direction: String): Query {\n        orderByClauses.add(new OrderClause(field, direction));\n        this\n      }\n\n      public limit(n: Int): Query {\n        limitValue = if (n \u003c 0) { 0 } else { n };\n        this\n      }\n\n      public offset(n: Int): Query {\n        offsetValue = n;\n        this\n      }\n\n      private matchesWhere(record: Record): Boolean {\n        for (let clause of whereClauses.toList()) {\n          let recordValue = record.getOr(clause.field, \u0022\u0022);\n          if (!schema.hasField(clause.field)) {\n            return false;\n          }\n          let fieldInfo = schema.getField(clause.field) orelse panic();\n          let fieldType = fieldInfo.fieldType;\n          let matches = when (fieldType) {\n            \u0022Int\u0022 -\u003e compareInt(recordValue, clause.operator, clause.value);\n            \u0022String\u0022 -\u003e compareString(recordValue, clause.operator, clause.value);\n            else -\u003e false;\n          };\n          if (!matches) {\n            return false;\n          }\n        }\n        true\n      }\n\n      private projectRecord(record: Record): Record {\n        if (selectFields.length == 0) {\n          return record;\n        }\n        let builder = new MapBuilder\u003cString, String\u003e();\n        for (let fieldName of selectFields) {\n          let value = record.getOr(fieldName, \u0022\u0022);\n          builder.set(fieldName, value);\n        }\n        new Record(builder.toMap())\n      }\n\n      private compareRecords(a: Record, b: Record, orderClauses: List\u003cOrderClause\u003e): Int {\n        for (let clause of orderClauses) {\n          let aVal = a.getOr(clause.field, \u0022\u0022);\n          let bVal = b.getOr(clause.field, \u0022\u0022);\n          if (!schema.hasField(clause.field)) {\n            continue;\n          }\n          let fieldInfo = schema.getField(clause.field) orelse panic();\n          let fieldType = fieldInfo.fieldType;\n          let cmp = when (fieldType) {\n            \u0022Int\u0022 -\u003e do {\n              let aInt = aVal.toInt32() orelse 0;\n              let bInt = bVal.toInt32() orelse 0;\n              aInt \u003c=\u003e bInt\n            };\n            \u0022String\u0022 -\u003e aVal \u003c=\u003e bVal;\n            else -\u003e 0;\n          };\n          if (cmp != 0) {\n            return if (clause.direction == \u0022desc\u0022) { -cmp } else { cmp };\n          }\n        }\n        0\n      }\n\n      public all(): List\u003cRecord\u003e {\n        let allRecords = store.all(schema.tableName);\n        let filtered = allRecords.filter { (r: Record): Boolean =\u003e\n          matchesWhere(r)\n        };\n        let sorted = if (orderByClauses.length \u003e 0) {\n          let clauses = orderByClauses.toList();\n          filtered.sorted { (a: Record, b: Record): Int =\u003e\n            compareRecords(a, b, clauses)\n          }\n        } else {\n          filtered\n        };\n        let sliced = if (limitValue \u003e= 0) {\n          let start = offsetValue;\n          let end = offsetValue + limitValue;\n          sorted.slice(start, end)\n        } else if (offsetValue \u003e 0) {\n          sorted.slice(offsetValue, sorted.length)\n        } else {\n          sorted\n        };\n        sliced.map { (r: Record): Record =\u003e projectRecord(r) }\n      }\n\n      public toSql(): SqlFragment {\n        toSqlQuery(schema, selectFields, whereClauses.toList(),\n                   orderByClauses.toList(), limitValue, offsetValue)\n      }\n    }\n\n    let compareInt(recordValue: String, operator: String, clauseValue: String): Boolean {\n      let rv = recordValue.toInt32() orelse 0;\n      let cv = clauseValue.toInt32() orelse 0;\n      if (clauseValue != cv.toString()) { return false; }\n      when (operator) {\n        \u0022==\u0022 -\u003e rv == cv;\n        \u0022!=\u0022 -\u003e rv != cv;\n        \u0022\u003e\u0022 -\u003e rv \u003e cv;\n        \u0022\u003c\u0022 -\u003e rv \u003c cv;\n        \u0022\u003e=\u0022 -\u003e rv \u003e= cv;\n        \u0022\u003c=\u0022 -\u003e rv \u003c= cv;\n        else -\u003e false;\n      }\n    }\n\n    let compareString(recordValue: String, operator: String, clauseValue: String): Boolean {\n      when (operator) {\n        \u0022==\u0022 -\u003e recordValue == clauseValue;\n        \u0022!=\u0022 -\u003e recordValue != clauseValue;\n        \u0022\u003e\u0022 -\u003e recordValue \u003e clauseValue;\n        \u0022\u003c\u0022 -\u003e recordValue \u003c clauseValue;\n        \u0022\u003e=\u0022 -\u003e recordValue \u003e= clauseValue;\n        \u0022\u003c=\u0022 -\u003e recordValue \u003c= clauseValue;\n        else -\u003e false;\n      }\n    }\n\n## SQL Generation\n\nPure functions that produce `SqlFragment` from query state using\nsecure-composition's `sql\u0022...\u0022` tagged strings. Interpolated values are\nautomatically escaped by type. Trusted SQL identifiers (table names, column\nnames, operators) are composed via fragment nesting.\n\n### Operator validation\n\nOnly allow known SQL comparison operators. Returns the operator if valid,\nor `=` as a safe fallback.\n\n    let validOperator(op: String): String {\n      when (op) {\n        \u0022=\u0022 -\u003e \u0022=\u0022;\n        \u0022==\u0022 -\u003e \u0022=\u0022;\n        \u0022!=\u0022 -\u003e \u0022!=\u0022;\n        \u0022\u003c\u003e\u0022 -\u003e \u0022\u003c\u003e\u0022;\n        \u0022\u003e\u0022 -\u003e \u0022\u003e\u0022;\n        \u0022\u003c\u0022 -\u003e \u0022\u003c\u0022;\n        \u0022\u003e=\u0022 -\u003e \u0022\u003e=\u0022;\n        \u0022\u003c=\u0022 -\u003e \u0022\u003c=\u0022;\n        else -\u003e \u0022=\u0022;\n      }\n    }\n\n### Trusted identifier fragment\n\nWraps a trusted identifier (table name, column name, operator) as a\n`SqlFragment`. These come from schema definitions, not user input.\n\n    let safeSql(trusted: String): SqlFragment {\n      let b = new SqlBuilder();\n      b.appendSafe(trusted);\n      b.accumulated\n    }\n\n### Column list helper\n\nBuilds the SELECT column list. If no fields specified, returns `*`.\n\n    let columnListSql(selectFields: List\u003cString\u003e): SqlFragment {\n      if (selectFields.length == 0) {\n        sql\u0022*\u0022\n      } else {\n        let first = safeSql(selectFields[0]);\n        var result = sql\u0022\u0024{first}\u0022;\n        for (var i = 1; i \u003c selectFields.length; i = i + 1) {\n          let col = safeSql(selectFields[i]);\n          result = sql\u0022\u0024{result}, \u0024{col}\u0022;\n        }\n        result\n      }\n    }\n\n### WHERE clause helper\n\nBuilds a single WHERE condition. The value is untrusted user input —\n`sql\u0022...\u0022` escapes it by type automatically.\n\n    let whereConditionSql(clause: WhereClause, schema: Schema): SqlFragment {\n      let col = safeSql(clause.field);\n      let op = safeSql(validOperator(clause.operator));\n      let fieldInfo = schema.getField(clause.field) orelse panic();\n      if (fieldInfo.fieldType == \u0022Int\u0022) {\n        let intVal = clause.value.toInt32() orelse 0;\n        if (clause.value != intVal.toString()) {\n          sql\u00221 = 0\u0022\n        } else {\n          sql\u0022\u0024{col} \u0024{op} \u0024{intVal}\u0022\n        }\n      } else {\n        let strVal = clause.value;\n        sql\u0022\u0024{col} \u0024{op} \u0024{strVal}\u0022\n      }\n    }\n\n### ORDER BY clause helper\n\n    let orderBySql(clauses: List\u003cOrderClause\u003e): SqlFragment {\n      let first = safeSql(clauses[0].field);\n      let firstDir = if (clauses[0].direction == \u0022desc\u0022) { safeSql(\u0022 DESC\u0022) } else { safeSql(\u0022 ASC\u0022) };\n      var result = sql\u0022\u0024{first}\u0024{firstDir}\u0022;\n      for (var i = 1; i \u003c clauses.length; i = i + 1) {\n        let col = safeSql(clauses[i].field);\n        let dir = if (clauses[i].direction == \u0022desc\u0022) { safeSql(\u0022 DESC\u0022) } else { safeSql(\u0022 ASC\u0022) };\n        result = sql\u0022\u0024{result}, \u0024{col}\u0024{dir}\u0022;\n      }\n      result\n    }\n\n### Full SELECT query builder\n\nAssembles a complete SELECT statement from parts. This is the main pure\nfunction: it takes query state in, returns `SqlFragment` out. Field names\nare validated against the schema — only declared fields pass through\n`safeSql`. Unknown fields are silently dropped, closing the confused deputy\nvector where user-controlled strings could reach `appendSafe`.\n\n    export let toSqlQuery(\n      schema: Schema,\n      selectFields: List\u003cString\u003e,\n      whereClauses: List\u003cWhereClause\u003e,\n      orderClauses: List\u003cOrderClause\u003e,\n      limitValue: Int,\n      offsetValue: Int,\n    ): SqlFragment {\n      let validSelect = selectFields.filter { (f: String): Boolean =\u003e\n        schema.hasField(f)\n      };\n      let validWhere = whereClauses.filter { (c: WhereClause): Boolean =\u003e\n        schema.hasField(c.field)\n      };\n      let validOrder = orderClauses.filter { (c: OrderClause): Boolean =\u003e\n        schema.hasField(c.field)\n      };\n      let table = safeSql(schema.tableName);\n      let cols = columnListSql(validSelect);\n      var result = sql\u0022SELECT \u0024{cols} FROM \u0024{table}\u0022;\n      if (validWhere.length \u003e 0) {\n        var conditions = whereConditionSql(validWhere[0], schema);\n        for (var i = 1; i \u003c validWhere.length; i = i + 1) {\n          let next = whereConditionSql(validWhere[i], schema);\n          conditions = sql\u0022\u0024{conditions} AND \u0024{next}\u0022;\n        }\n        result = sql\u0022\u0024{result} WHERE \u0024{conditions}\u0022;\n      }\n      if (validOrder.length \u003e 0) {\n        let ordering = orderBySql(validOrder);\n        result = sql\u0022\u0024{result} ORDER BY \u0024{ordering}\u0022;\n      }\n      if (limitValue \u003e= 0) {\n        result = sql\u0022\u0024{result} LIMIT \u0024{limitValue}\u0022;\n      }\n      if (offsetValue \u003e 0) {\n        result = sql\u0022\u0024{result} OFFSET \u0024{offsetValue}\u0022;\n      }\n      result\n    }\n\n### INSERT statement builder\n\nGenerates an INSERT statement from a schema and a map of field values.\nField names come from the schema (trusted). Values are escaped via\n`sql\u0022...\u0022` by type.\n\n    export let toInsertSql(\n      schema: Schema,\n      values: Map\u003cString, String\u003e,\n    ): SqlFragment {\n      let table = safeSql(schema.tableName);\n      let fieldList = schema.fields.filter { (f: Field): Boolean =\u003e\n        values.has(f.name)\n      };\n      if (fieldList.length == 0) {\n        return sql\u0022\u0022;\n      }\n      let colNames = columnListSql(\n        fieldList.map { (f: Field): String =\u003e f.name }\n      );\n      let firstVal = values.getOr(fieldList[0].name, \u0022\u0022);\n      var vals = if (fieldList[0].fieldType == \u0022Int\u0022) {\n        let iv = firstVal.toInt32() orelse 0;\n        sql\u0022\u0024{iv}\u0022\n      } else {\n        sql\u0022\u0024{firstVal}\u0022\n      };\n      for (var i = 1; i \u003c fieldList.length; i = i + 1) {\n        let val = values.getOr(fieldList[i].name, \u0022\u0022);\n        if (fieldList[i].fieldType == \u0022Int\u0022) {\n          let iv = val.toInt32() orelse 0;\n          vals = sql\u0022\u0024{vals}, \u0024{iv}\u0022;\n        } else {\n          vals = sql\u0022\u0024{vals}, \u0024{val}\u0022;\n        }\n      }\n      sql\u0022INSERT INTO \u0024{table} (\u0024{colNames}) VALUES (\u0024{vals})\u0022\n    }\n\n## SQL Generation Tests\n\n### Basic SELECT\n\n    test(\u0022toSql: select all\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n### SELECT with specific columns\n\n    test(\u0022toSql: select columns\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).select([\u0022name\u0022, \u0022age\u0022]);\n      assert(q.toSql().toString() == \u0022SELECT name, age FROM users\u0022);\n    }\n\n### WHERE with string value\n\n    test(\u0022toSql: where string\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### WHERE with integer value\n\n    test(\u0022toSql: where int\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE age \u003e= 18\u0022);\n    }\n\n### SQL injection protection\n\nThe Bobby Tables attack string is safely escaped — single quotes are doubled.\n\n    test(\u0022toSql: SQL injection blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let bobby = \u0022Robert'); DROP TABLE users;--\u0022;\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, bobby);\n      let result = q.toSql().toString();\n      assert(result == \u0022SELECT * FROM users WHERE name = 'Robert''); DROP TABLE users;--'\u0022);\n    }\n\n### Operator normalization\n\nThe `==` operator from the in-memory query API is normalized to SQL `=`.\n\n    test(\u0022toSql: operator normalization\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022==\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### Invalid operator fallback\n\nUnknown operators fall back to `=` for safety.\n\n    test(\u0022toSql: invalid operator fallback\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022LIKE\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### Multiple WHERE clauses\n\n    test(\u0022toSql: multiple where\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .where(\u0022age\u0022, \u0022\u003c\u0022, \u002230\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE age \u003e= 18 AND age \u003c 30\u0022);\n    }\n\n### ORDER BY\n\n    test(\u0022toSql: order by\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).orderBy(\u0022name\u0022, \u0022asc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users ORDER BY name ASC\u0022);\n    }\n\n### ORDER BY descending\n\n    test(\u0022toSql: order by desc\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).orderBy(\u0022age\u0022, \u0022desc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users ORDER BY age DESC\u0022);\n    }\n\n### LIMIT and OFFSET\n\n    test(\u0022toSql: limit\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).limit(10);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users LIMIT 10\u0022);\n    }\n\n    test(\u0022toSql: offset\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).offset(5);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users OFFSET 5\u0022);\n    }\n\n### Complex query\n\n    test(\u0022toSql: complex query\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .select([\u0022name\u0022, \u0022age\u0022])\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .orderBy(\u0022age\u0022, \u0022desc\u0022)\n        .limit(10)\n        .offset(20);\n      assert(q.toSql().toString() ==\n        \u0022SELECT name, age FROM users WHERE age \u003e= 18 ORDER BY age DESC LIMIT 10 OFFSET 20\u0022);\n    }\n\n### Unicode in values\n\n    test(\u0022toSql: unicode escaping\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022Hello 世界\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Hello 世界'\u0022);\n    }\n\n### Embedded quotes in values\n\n    test(\u0022toSql: embedded quotes\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022O'Brien\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'O''Brien'\u0022);\n    }\n\n### Empty string value\n\n    test(\u0022toSql: empty string\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = ''\u0022);\n    }\n\n### INSERT statement\n\n    test(\u0022toInsertSql: basic insert\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u002225\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() == \u0022INSERT INTO users (name, age) VALUES ('Alice', 25)\u0022);\n    }\n\n### INSERT with injection protection\n\n    test(\u0022toInsertSql: injection blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Robert'); DROP TABLE users;--\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() ==\n        \u0022INSERT INTO users (name) VALUES ('Robert''); DROP TABLE users;--')\u0022);\n    }\n\n### toSqlQuery as standalone pure function\n\n    test(\u0022toSqlQuery: standalone\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let result = toSqlQuery(\n        s, [\u0022name\u0022], [new WhereClause(\u0022age\u0022, \u0022\u003e\u0022, \u002221\u0022)],\n        [new OrderClause(\u0022name\u0022, \u0022asc\u0022)], 5, 0,\n      );\n      assert(result.toString() ==\n        \u0022SELECT name FROM users WHERE age \u003e 21 ORDER BY name ASC LIMIT 5\u0022);\n    }\n\n### Adversarial field name protection\n\nField names not in the schema are silently dropped from SQL generation.\nThis prevents confused deputy attacks where user-controlled strings\ncould reach `appendSafe` through field name positions.\n\n    test(\u0022toSql: adversarial field name blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .where(\u00221=1; DROP TABLE users; --\u0022, \u0022=\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n    test(\u0022toSql: adversarial select column blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .select([\u0022name\u0022, \u00221; DROP TABLE users\u0022]);\n      assert(q.toSql().toString() == \u0022SELECT name FROM users\u0022);\n    }\n\n    test(\u0022toSql: adversarial order by blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .orderBy(\u00221; DROP TABLE users\u0022, \u0022asc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n## Security Audit Fix Tests\n\n### Fix #1: Table name validation\n\n    test(\u0022isValidIdentifier: valid names\u0022) {\n      assert(isValidIdentifier(\u0022users\u0022));\n      assert(isValidIdentifier(\u0022user_table\u0022));\n      assert(isValidIdentifier(\u0022Table1\u0022));\n      assert(isValidIdentifier(\u0022_private\u0022));\n      assert(isValidIdentifier(\u0022a\u0022));\n    }\n\n    test(\u0022isValidIdentifier: invalid names\u0022) {\n      assert(!isValidIdentifier(\u0022\u0022));\n      assert(!isValidIdentifier(\u0022users; DROP TABLE\u0022));\n      assert(!isValidIdentifier(\u0022users--\u0022));\n      assert(!isValidIdentifier(\u0022ta ble\u0022));\n      assert(!isValidIdentifier(\u0022table.name\u0022));\n      assert(!isValidIdentifier(\u0022Robert'); DROP TABLE users;--\u0022));\n    }\n\n### Fix #3: Non-numeric value for Int field\n\n    test(\u0022toSql: non-numeric Int value produces always-false\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022age\u0022, \u0022=\u0022, \u0022admin\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE 1 = 0\u0022);\n    }\n\n    test(\u0022in-memory: non-numeric Int value matches nothing\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u00220\u0022),\n      ]));\n      let results = new Query(s, store).where(\u0022age\u0022, \u0022=\u0022, \u0022admin\u0022).all();\n      assert(results.length == 0);\n    }\n\n### Fix #5: LIMIT zero and negative\n\n    test(\u0022toSql: limit zero emits LIMIT 0\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).limit(0);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users LIMIT 0\u0022);\n    }\n\n    test(\u0022in-memory: limit zero returns empty\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n      ]));\n      let results = new Query(s, store).limit(0).all();\n      assert(results.length == 0);\n    }\n\n    test(\u0022in-memory: negative limit clamped to zero\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n      ]));\n      let results = new Query(s, store).limit(-5).all();\n      assert(results.length == 0);\n    }\n\n### Fix #6: Empty insert safety\n\n    test(\u0022toInsertSql: no matching fields returns empty\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022nonexistent\u0022, \u0022value\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() == \u0022\u0022);\n    }\n\n## Demo\n\n    export let main(): Void {\n      console.log(\u0022=== ORMery Demo ===\\n\u0022);\n\n      let userFields = [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n        field(\u0022email\u0022, \u0022String\u0022, false, true),\n      ];\n      let userSchema = schema(\u0022users\u0022, userFields);\n\n      console.log(userSchema.describe());\n      console.log(\u0022\u0022);\n\n      let store = new InMemoryStore();\n\n      let rec1 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u002225\u0022),\n        new Pair(\u0022email\u0022, \u0022alice@example.com\u0022),\n      ]));\n\n      let rec2 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Bob\u0022),\n        new Pair(\u0022age\u0022, \u002230\u0022),\n        new Pair(\u0022email\u0022, \u0022bob@example.com\u0022),\n      ]));\n\n      let rec3 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Charlie\u0022),\n        new Pair(\u0022age\u0022, \u002217\u0022),\n        new Pair(\u0022email\u0022, \u0022charlie@example.com\u0022),\n      ]));\n\n      console.log(\u0022Inserted 3 users:\u0022);\n      console.log(\u0022  \u0024{rec1.describe()}\u0022);\n      console.log(\u0022  \u0024{rec2.describe()}\u0022);\n      console.log(\u0022  \u0024{rec3.describe()}\u0022);\n      console.log(\u0022\u0022);\n\n      console.log(\u0022=== In-Memory Queries ===\\n\u0022);\n\n      console.log(\u0022All users:\u0022);\n      let allUsers = new Query(userSchema, store).all();\n      for (let u of allUsers) {\n        console.log(\u0022  \u0024{u.describe()}\u0022);\n      }\n      console.log(\u0022\u0022);\n\n      console.log(\u0022Adults (age \u003e= 18):\u0022);\n      let adults = new Query(userSchema, store)\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .all();\n      for (let u of adults) {\n        console.log(\u0022  \u0024{u.describe()}\u0022);\n      }\n      console.log(\u0022\u0022);\n\n      console.log(\u0022=== SQL Generation (secure-composition) ===\\n\u0022);\n\n      let q1 = new Query(userSchema, store);\n      console.log(\u0022SELECT all: \u0024{q1.toSql().toString()}\u0022);\n\n      let q2 = new Query(userSchema, store)\n        .select([\u0022name\u0022, \u0022age\u0022])\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .orderBy(\u0022age\u0022, \u0022desc\u0022)\n        .limit(10);\n      console.log(\u0022Complex:    \u0024{q2.toSql().toString()}\u0022);\n\n      let bobby = \u0022Robert'); DROP TABLE users;--\u0022;\n      let q3 = new Query(userSchema, store)\n        .where(\u0022name\u0022, \u0022=\u0022, bobby);\n      console.log(\u0022Injection:  \u0024{q3.toSql().toString()}\u0022);\n\n      let insertVals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022O'Malley\u0022),\n        new Pair(\u0022age\u0022, \u002242\u0022),\n      ]);\n      console.log(\u0022INSERT:     \u0024{toInsertSql(userSchema, insertVals).toString()}\u0022);\n\n      console.log(\u0022\\n=== Demo Complete ===\u0022);\n    }\n" ], "names": [ "SqlFragment", "Query", "Schema", "schema", "InMemoryStore", "store", "WhereClause", "whereClauses", "selectFields", "OrderClause", "orderByClauses", "limitValue", "offsetValue", "t#3898", "t#2220", "t#3899", "field", "operator", "value", "t#3896", "fields", "direction", "t#3894", "n", "t#2209", "Record", "record", "return", "t#3883", "t#3885", "t#3887", "t#3889", "t#3890", "t#3891", "t#3892", "t#3893", "fn", "this", "i", "el", "clause", "recordValue", "Field", "t#2198", "fieldInfo", "fieldType", "matches", "compareInt", "compareString", "t#3878", "builder", "fieldName", "a", "b", "orderClauses", "t#3862", "t#3864", "t#3866", "t#3868", "t#2177", "t#2179", "aVal", "bVal", "t#2174", "cmp", "aInt", "aInt#5869", "bInt", "bInt#5870", "t#3853", "t#3854", "t#3855", "t#3856", "t#3857", "t#3846", "allRecords", "r", "filtered", "sorted", "clauses", "sliced", "start", "end", "toSqlQuery" ], "mappings": "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" }