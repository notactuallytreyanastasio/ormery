{ "version": 3, "file": "java/ormery/src/main/java/ormery/OrmeryGlobal.java", "sourceRoot": "-work/src/", "sources": [ "demo-controller.temper.md", "syntax-highlighter.temper.md", "ormery.temper.md" ], "sourcesContent": [ "# Demo Controller\n\nBusiness logic for the ORMery tutorial demo, written in Temper.\n\n## DemoController Class\n\n    export class DemoController(\n      public schema: Schema,\n      public store: InMemoryStore,\n    ) {\n      private var queryCount: Int;\n\n      public constructor(schema: Schema, store: InMemoryStore) {\n        this.schema = schema;\n        this.store = store;\n        queryCount = 0;\n      }\n\n      // Get total record count\n      public getRecordCount(): Int {\n        store.count(schema.tableName)\n      }\n\n      // Get count of adults (age \u003e= 18)\n      public getAdultCount(): Int {\n        new Query(schema, store)\n          .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n          .all()\n          .length\n      }\n\n      // Get number of queries run\n      public getQueryCount(): Int {\n        queryCount\n      }\n\n      // Increment query counter\n      private incrementQueryCount(): Void {\n        queryCount = queryCount + 1;\n      }\n\n      // Format a list of records as text\n      private formatRecords(records: List\u003cRecord\u003e): String {\n        let lines = records.map { (record: Record): String =\u003e\n          \u0022  \u0024{record.describe()}\u0022\n        };\n        lines.join(\u0022\\n\u0022) { (s: String): String =\u003e s }\n      }\n\n      // Demo 1: Get all users\n      public runDemo1(): String {\n        incrementQueryCount();\n        let results = new Query(schema, store).all();\n        let formatted = formatRecords(results);\n        \u0022=== Demo 1: All Users ===\\n\\nQuery: new Query(userSchema, store).all()\\n\\nResults:\\n\u0024{formatted}\\n\\nTotal: \u0024{results.length} records\u0022\n      }\n\n      // Demo 2: Filter adults (age \u003e= 18)\n      public runDemo2(): String {\n        incrementQueryCount();\n        let results = new Query(schema, store)\n          .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n          .all();\n        let formatted = formatRecords(results);\n        \u0022=== Demo 2: Filter Adults ===\\n\\nQuery: new Query(userSchema, store)\\n  .where(\\\u0022age\\\u0022, \\\u0022\u003e=\\\u0022, \\\u002218\\\u0022)\\n  .all()\\n\\nResults:\\n\u0024{formatted}\\n\\nTotal: \u0024{results.length} adults found\u0022\n      }\n\n      // Demo 3: Sort by age descending\n      public runDemo3(): String {\n        incrementQueryCount();\n        let results = new Query(schema, store)\n          .orderBy(\u0022age\u0022, \u0022desc\u0022)\n          .all();\n        let formatted = formatRecords(results);\n        \u0022=== Demo 3: Sort by Age (Descending) ===\\n\\nQuery: new Query(userSchema, store)\\n  .orderBy(\\\u0022age\\\u0022, \\\u0022desc\\\u0022)\\n  .all()\\n\\nResults (ordered by age, oldest first):\\n\u0024{formatted}\u0022\n      }\n\n      // Demo 4: Pagination\n      public runDemo4(): String {\n        incrementQueryCount();\n        let page1 = new Query(schema, store)\n          .orderBy(\u0022id\u0022, \u0022asc\u0022)\n          .limit(2)\n          .all();\n        let page2 = new Query(schema, store)\n          .orderBy(\u0022id\u0022, \u0022asc\u0022)\n          .offset(2)\n          .limit(2)\n          .all();\n        let formatted1 = formatRecords(page1);\n        let formatted2 = formatRecords(page2);\n        \u0022=== Demo 4: Pagination ===\\n\\nPage 1: .orderBy(\\\u0022id\\\u0022, \\\u0022asc\\\u0022).limit(2)\\n\\n\u0024{formatted1}\\n\\nPage 2: .orderBy(\\\u0022id\\\u0022, \\\u0022asc\\\u0022).offset(2).limit(2)\\n\\n\u0024{formatted2}\u0022\n      }\n\n      // Demo 5: Complex query with all features\n      public runDemo5(): String {\n        incrementQueryCount();\n        let results = new Query(schema, store)\n          .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n          .where(\u0022email\u0022, \u0022!=\u0022, \u0022\u0022)\n          .orderBy(\u0022age\u0022, \u0022desc\u0022)\n          .select([\u0022name\u0022, \u0022age\u0022])\n          .limit(2)\n          .all();\n        let formatted = formatRecords(results);\n        \u0022=== Demo 5: Complex Query ===\\n\\nQuery: new Query(userSchema, store)\\n  .where(\\\u0022age\\\u0022, \\\u0022\u003e=\\\u0022, \\\u002218\\\u0022)\\n  .where(\\\u0022email\\\u0022, \\\u0022!=\\\u0022, \\\u0022\\\u0022)\\n  .orderBy(\\\u0022age\\\u0022, \\\u0022desc\\\u0022)\\n  .select([\\\u0022name\\\u0022, \\\u0022age\\\u0022])\\n  .limit(2)\\n  .all()\\n\\nResults (adults with email, showing name/age only, oldest first, max 2):\\n\u0024{formatted}\u0022\n      }\n    }\n", "# Temper Syntax Highlighter\n\nA syntax highlighter for Temper code, written in Temper. Uses\nsecure-composition's `html\u0022...\u0022` tagged strings for contextual\nauto-escaping — values interpolated into element content are\nHTML-entity-encoded automatically.\n\n    let { html, SafeHtml } = import(\u0022./html\u0022);\n\n## Token Types\n\n    export class TokenType(public name: String) {\n      public get isKeyword(): Boolean { name == \u0022keyword\u0022 }\n      public get isType(): Boolean { name == \u0022type\u0022 }\n      public get isString(): Boolean { name == \u0022string\u0022 }\n      public get isNumber(): Boolean { name == \u0022number\u0022 }\n      public get isComment(): Boolean { name == \u0022comment\u0022 }\n      public get isOperator(): Boolean { name == \u0022operator\u0022 }\n      public get isIdentifier(): Boolean { name == \u0022identifier\u0022 }\n    }\n\n## Token\n\n    export class Token(\n      public tokenType: TokenType,\n      public value: String,\n    ) {\n      public cssClass(): String {\n        let name = tokenType.name;\n        when (name) {\n          \u0022keyword\u0022 -\u003e \u0022kw\u0022;\n          \u0022type\u0022 -\u003e \u0022typ\u0022;\n          \u0022string\u0022 -\u003e \u0022str\u0022;\n          \u0022number\u0022 -\u003e \u0022num\u0022;\n          \u0022comment\u0022 -\u003e \u0022cmt\u0022;\n          \u0022operator\u0022 -\u003e \u0022op\u0022;\n          else -\u003e \u0022id\u0022;\n        }\n      }\n\n      public toHtml(): SafeHtml {\n        let cls = cssClass();\n        html\u0022\u003cspan class='\u0024{cls}'\u003e\u0024{value}\u003c/span\u003e\u0022\n      }\n    }\n\n## Keyword and Type Lists\n\n    let temperKeywords: List\u003cString\u003e = [\n      \u0022if\u0022, \u0022else\u0022, \u0022for\u0022, \u0022while\u0022, \u0022do\u0022, \u0022when\u0022, \u0022break\u0022, \u0022continue\u0022, \u0022return\u0022,\n      \u0022let\u0022, \u0022var\u0022, \u0022class\u0022, \u0022export\u0022, \u0022import\u0022, \u0022public\u0022, \u0022private\u0022, \u0022protected\u0022,\n      \u0022throws\u0022, \u0022new\u0022, \u0022this\u0022, \u0022get\u0022, \u0022set\u0022, \u0022static\u0022, \u0022extends\u0022, \u0022implements\u0022,\n      \u0022true\u0022, \u0022false\u0022, \u0022null\u0022, \u0022bubble\u0022, \u0022orelse\u0022, \u0022of\u0022,\n    ];\n\n    let temperTypes: List\u003cString\u003e = [\n      \u0022String\u0022, \u0022Int\u0022, \u0022Boolean\u0022, \u0022List\u0022, \u0022Map\u0022, \u0022Bubble\u0022, \u0022Pair\u0022,\n      \u0022Float\u0022, \u0022Double\u0022, \u0022Byte\u0022, \u0022Short\u0022, \u0022Long\u0022, \u0022Char\u0022, \u0022Void\u0022,\n      \u0022Record\u0022, \u0022Schema\u0022, \u0022Field\u0022, \u0022Query\u0022, \u0022InMemoryStore\u0022,\n      \u0022ListBuilder\u0022, \u0022MapBuilder\u0022, \u0022WhereClause\u0022, \u0022OrderClause\u0022,\n    ];\n\n## Classifier\n\nClassifies a word token based on known keywords and types.\n\n    export let classifyWord(word: String): TokenType {\n      for (let kw of temperKeywords) {\n        if (kw == word) {\n          return new TokenType(\u0022keyword\u0022);\n        }\n      }\n      for (let tp of temperTypes) {\n        if (tp == word) {\n          return new TokenType(\u0022type\u0022);\n        }\n      }\n      new TokenType(\u0022identifier\u0022)\n    }\n\n## Simple Line Highlighter\n\nSince Temper's String type works with code points and StringIndex rather than\ninteger-indexed substring operations, we use a word-level approach: split each\nline by spaces and classify each token.\n\n    export let highlightWord(word: String): SafeHtml {\n      if (word == \u0022\u0022) {\n        return html\u0022\u0022;\n      }\n      let tokenType = classifyWord(word);\n      let token = new Token(tokenType, word);\n      token.toHtml()\n    }\n\n    export let highlightLine(line: String): SafeHtml {\n      let words = line.split(\u0022 \u0022);\n      if (words.length == 0) {\n        return html\u0022\u0022;\n      }\n      var result = highlightWord(words[0]);\n      for (var i = 1; i \u003c words.length; i = i + 1) {\n        let word = highlightWord(words[i]);\n        result = html\u0022\u0024{result} \u0024{word}\u0022;\n      }\n      result\n    }\n\n    export let highlightSource(source: String): SafeHtml {\n      let lines = source.split(\u0022\\n\u0022);\n      if (lines.length == 0) {\n        return html\u0022\u0022;\n      }\n      var result = highlightLine(lines[0]);\n      for (var i = 1; i \u003c lines.length; i = i + 1) {\n        let line = highlightLine(lines[i]);\n        result = html\u0022\u0024{result}\\n\u0024{line}\u0022;\n      }\n      result\n    }\n\n    export let highlightBlock(source: String): SafeHtml {\n      let highlighted = highlightSource(source);\n      html\u0022\u003cpre class='temper-code'\u003e\u003ccode\u003e\u0024{highlighted}\u003c/code\u003e\u003c/pre\u003e\u0022\n    }\n", "# ORMery - All-in-One Demo\n\nA simplified version of Ecto in Temper, using secure-composition for\ninjection-proof SQL generation.\n\n    let { sql, SqlFragment, SqlBuilder } = import(\u0022./sql\u0022);\n\n## Field and Schema\n\n    export class Field(\n      public name: String,\n      public fieldType: String,\n      public primaryKey: Boolean,\n      public nullable: Boolean,\n    ) {\n      public get description(): String {\n        let pk = if (primaryKey) { \u0022 (PK)\u0022 } else { \u0022\u0022 };\n        let null = if (nullable) { \u0022 (nullable)\u0022 } else { \u0022\u0022 };\n        \u0022\u0024{name}: \u0024{fieldType}\u0024{pk}\u0024{null}\u0022\n      }\n    }\n\n    export class Schema(\n      public tableName: String,\n      public fields: List\u003cField\u003e,\n    ) {\n      public getField(name: String): Field throws Bubble {\n        for (let field of fields) {\n          if (field.name == name) {\n            return field;\n          }\n        }\n        bubble()\n      }\n\n      public hasField(name: String): Boolean {\n        for (let field of fields) {\n          if (field.name == name) {\n            return true;\n          }\n        }\n        false\n      }\n\n      public get primaryKeyField(): Field throws Bubble {\n        for (let field of fields) {\n          if (field.primaryKey) {\n            return field;\n          }\n        }\n        bubble()\n      }\n\n      public get fieldNames(): List\u003cString\u003e {\n        fields.map { (f: Field): String =\u003e f.name }\n      }\n\n      public describe(): String {\n        let header = \u0022Schema: \u0024{tableName}\\n\u0022;\n        let fieldList = fields\n          .map { (f: Field): String =\u003e \u0022  - \u0024{f.description}\u0022 }\n          .join(\u0022\\n\u0022) { (s: String): String =\u003e s };\n        \u0022\u0024{header}\u0024{fieldList}\u0022\n      }\n    }\n\n    export let field(\n      name: String,\n      fieldType: String,\n      primaryKey: Boolean,\n      nullable: Boolean,\n    ): Field {\n      new Field(name, fieldType, primaryKey, nullable)\n    }\n\n### Identifier validation\n\nOnly allow safe SQL identifier characters: `a-z`, `A-Z`, `0-9`, `_`.\nThis closes the table name backdoor where `schema()` accepted arbitrary\nstrings that passed through `safeSql()` → `appendSafe()` unescaped.\n\n    export let isValidIdentifier(name: String): Boolean {\n      if (name.isEmpty) { return false; }\n      for (let c of name) {\n        if (c != char'_') {\n          if (c \u003e= char'a') {\n            if (c \u003e char'z') { return false; }\n          } else if (c \u003e= char'A') {\n            if (c \u003e char'Z') { return false; }\n          } else if (c \u003e= char'0') {\n            if (c \u003e char'9') { return false; }\n          } else {\n            return false;\n          }\n        }\n      }\n      true\n    }\n\n    export let schema(tableName: String, fields: List\u003cField\u003e): Schema {\n      if (!isValidIdentifier(tableName)) { panic(); }\n      let idField = new Field(\u0022id\u0022, \u0022Int\u0022, true, false);\n      let allFields = new ListBuilder\u003cField\u003e();\n      allFields.add(idField);\n      allFields.addAll(fields);\n      new Schema(tableName, allFields.toList())\n    }\n\n## Record and Store\n\n    export class Record(\n      public data: Map\u003cString, String\u003e,\n    ) {\n      public get(field: String): String throws Bubble {\n        data.get(field)\n      }\n\n      public getOr(field: String, fallback: String): String {\n        data.getOr(field, fallback)\n      }\n\n      public has(field: String): Boolean {\n        data.has(field)\n      }\n\n      public get id(): Int throws Bubble {\n        let idStr = data.get(\u0022id\u0022);\n        idStr.toInt32() orelse bubble()\n      }\n\n      public describe(): String {\n        let pairs = data.toListWith { (k: String, v: String): String =\u003e\n          \u0022\u0024{k}: \u0024{v}\u0022\n        };\n        pairs.join(\u0022, \u0022) { (s: String): String =\u003e s }\n      }\n    }\n\n    export class InMemoryStore() {\n      private var tables: MapBuilder\u003cString, ListBuilder\u003cRecord\u003e\u003e;\n      private var nextIds: MapBuilder\u003cString, Int\u003e;\n\n      public constructor() {\n        tables = new MapBuilder\u003cString, ListBuilder\u003cRecord\u003e\u003e();\n        nextIds = new MapBuilder\u003cString, Int\u003e();\n      }\n\n      private ensureTable(tableName: String): Void {\n        if (!tables.has(tableName)) {\n          tables.set(tableName, new ListBuilder\u003cRecord\u003e());\n          nextIds.set(tableName, 1);\n        }\n      }\n\n      public insert(tableName: String, data: Map\u003cString, String\u003e): Record {\n        ensureTable(tableName);\n        let id = nextIds.getOr(tableName, 1);\n        nextIds.set(tableName, id + 1);\n\n        let dataBuilder = data.toMapBuilder();\n        dataBuilder.set(\u0022id\u0022, id.toString());\n        let record = new Record(dataBuilder.toMap());\n\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.add(record);\n        record\n      }\n\n      public all(tableName: String): List\u003cRecord\u003e {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.toList()\n      }\n\n      public get(tableName: String, id: Int): Record throws Bubble {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n\n        for (let record of table.toList()) {\n          let recordId = record.id orelse bubble();\n          if (recordId == id) {\n            return record;\n          }\n        }\n        bubble()\n      }\n\n      public count(tableName: String): Int {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.length\n      }\n    }\n\n## Query Builder\n\n    export class WhereClause(\n      public field: String,\n      public operator: String,\n      public value: String,\n    ) {\n      public describe(): String {\n        \u0022\u0024{field} \u0024{operator} \u0024{value}\u0022\n      }\n    }\n\n    export class OrderClause(\n      public field: String,\n      public direction: String,\n    ) {\n      public describe(): String {\n        \u0022\u0024{field} \u0024{direction}\u0022\n      }\n    }\n\n    export class Query(\n      public schema: Schema,\n      public store: InMemoryStore,\n    ) {\n      private var whereClauses: ListBuilder\u003cWhereClause\u003e;\n      private var selectFields: List\u003cString\u003e;\n      private var orderByClauses: ListBuilder\u003cOrderClause\u003e;\n      private var limitValue: Int;\n      private var offsetValue: Int;\n\n      public constructor(schema: Schema, store: InMemoryStore) {\n        this.schema = schema;\n        this.store = store;\n        whereClauses = new ListBuilder\u003cWhereClause\u003e();\n        selectFields = [];\n        orderByClauses = new ListBuilder\u003cOrderClause\u003e();\n        limitValue = -1;\n        offsetValue = 0;\n      }\n\n      public where(field: String, operator: String, value: String): Query {\n        whereClauses.add(new WhereClause(field, operator, value));\n        this\n      }\n\n      public select(fields: List\u003cString\u003e): Query {\n        selectFields = fields;\n        this\n      }\n\n      public orderBy(field: String, direction: String): Query {\n        orderByClauses.add(new OrderClause(field, direction));\n        this\n      }\n\n      public limit(n: Int): Query {\n        limitValue = if (n \u003c 0) { 0 } else { n };\n        this\n      }\n\n      public offset(n: Int): Query {\n        offsetValue = n;\n        this\n      }\n\n      private matchesWhere(record: Record): Boolean {\n        for (let clause of whereClauses.toList()) {\n          let recordValue = record.getOr(clause.field, \u0022\u0022);\n          if (!schema.hasField(clause.field)) {\n            return false;\n          }\n          let fieldInfo = schema.getField(clause.field) orelse panic();\n          let fieldType = fieldInfo.fieldType;\n          let matches = when (fieldType) {\n            \u0022Int\u0022 -\u003e compareInt(recordValue, clause.operator, clause.value);\n            \u0022String\u0022 -\u003e compareString(recordValue, clause.operator, clause.value);\n            else -\u003e false;\n          };\n          if (!matches) {\n            return false;\n          }\n        }\n        true\n      }\n\n      private projectRecord(record: Record): Record {\n        if (selectFields.length == 0) {\n          return record;\n        }\n        let builder = new MapBuilder\u003cString, String\u003e();\n        for (let fieldName of selectFields) {\n          let value = record.getOr(fieldName, \u0022\u0022);\n          builder.set(fieldName, value);\n        }\n        new Record(builder.toMap())\n      }\n\n      private compareRecords(a: Record, b: Record, orderClauses: List\u003cOrderClause\u003e): Int {\n        for (let clause of orderClauses) {\n          let aVal = a.getOr(clause.field, \u0022\u0022);\n          let bVal = b.getOr(clause.field, \u0022\u0022);\n          if (!schema.hasField(clause.field)) {\n            continue;\n          }\n          let fieldInfo = schema.getField(clause.field) orelse panic();\n          let fieldType = fieldInfo.fieldType;\n          let cmp = when (fieldType) {\n            \u0022Int\u0022 -\u003e do {\n              let aInt = aVal.toInt32() orelse 0;\n              let bInt = bVal.toInt32() orelse 0;\n              aInt \u003c=\u003e bInt\n            };\n            \u0022String\u0022 -\u003e aVal \u003c=\u003e bVal;\n            else -\u003e 0;\n          };\n          if (cmp != 0) {\n            return if (clause.direction == \u0022desc\u0022) { -cmp } else { cmp };\n          }\n        }\n        0\n      }\n\n      public all(): List\u003cRecord\u003e {\n        let allRecords = store.all(schema.tableName);\n        let filtered = allRecords.filter { (r: Record): Boolean =\u003e\n          matchesWhere(r)\n        };\n        let sorted = if (orderByClauses.length \u003e 0) {\n          let clauses = orderByClauses.toList();\n          filtered.sorted { (a: Record, b: Record): Int =\u003e\n            compareRecords(a, b, clauses)\n          }\n        } else {\n          filtered\n        };\n        let sliced = if (limitValue \u003e= 0) {\n          let start = offsetValue;\n          let end = offsetValue + limitValue;\n          sorted.slice(start, end)\n        } else if (offsetValue \u003e 0) {\n          sorted.slice(offsetValue, sorted.length)\n        } else {\n          sorted\n        };\n        sliced.map { (r: Record): Record =\u003e projectRecord(r) }\n      }\n\n      public toSql(): SqlFragment {\n        toSqlQuery(schema, selectFields, whereClauses.toList(),\n                   orderByClauses.toList(), limitValue, offsetValue)\n      }\n    }\n\n    let compareInt(recordValue: String, operator: String, clauseValue: String): Boolean {\n      let rv = recordValue.toInt32() orelse 0;\n      let cv = clauseValue.toInt32() orelse 0;\n      if (clauseValue != cv.toString()) { return false; }\n      when (operator) {\n        \u0022==\u0022 -\u003e rv == cv;\n        \u0022!=\u0022 -\u003e rv != cv;\n        \u0022\u003e\u0022 -\u003e rv \u003e cv;\n        \u0022\u003c\u0022 -\u003e rv \u003c cv;\n        \u0022\u003e=\u0022 -\u003e rv \u003e= cv;\n        \u0022\u003c=\u0022 -\u003e rv \u003c= cv;\n        else -\u003e false;\n      }\n    }\n\n    let compareString(recordValue: String, operator: String, clauseValue: String): Boolean {\n      when (operator) {\n        \u0022==\u0022 -\u003e recordValue == clauseValue;\n        \u0022!=\u0022 -\u003e recordValue != clauseValue;\n        \u0022\u003e\u0022 -\u003e recordValue \u003e clauseValue;\n        \u0022\u003c\u0022 -\u003e recordValue \u003c clauseValue;\n        \u0022\u003e=\u0022 -\u003e recordValue \u003e= clauseValue;\n        \u0022\u003c=\u0022 -\u003e recordValue \u003c= clauseValue;\n        else -\u003e false;\n      }\n    }\n\n## SQL Generation\n\nPure functions that produce `SqlFragment` from query state using\nsecure-composition's `sql\u0022...\u0022` tagged strings. Interpolated values are\nautomatically escaped by type. Trusted SQL identifiers (table names, column\nnames, operators) are composed via fragment nesting.\n\n### Operator validation\n\nOnly allow known SQL comparison operators. Returns the operator if valid,\nor `=` as a safe fallback.\n\n    let validOperator(op: String): String {\n      when (op) {\n        \u0022=\u0022 -\u003e \u0022=\u0022;\n        \u0022==\u0022 -\u003e \u0022=\u0022;\n        \u0022!=\u0022 -\u003e \u0022!=\u0022;\n        \u0022\u003c\u003e\u0022 -\u003e \u0022\u003c\u003e\u0022;\n        \u0022\u003e\u0022 -\u003e \u0022\u003e\u0022;\n        \u0022\u003c\u0022 -\u003e \u0022\u003c\u0022;\n        \u0022\u003e=\u0022 -\u003e \u0022\u003e=\u0022;\n        \u0022\u003c=\u0022 -\u003e \u0022\u003c=\u0022;\n        else -\u003e \u0022=\u0022;\n      }\n    }\n\n### Trusted identifier fragment\n\nWraps a trusted identifier (table name, column name, operator) as a\n`SqlFragment`. These come from schema definitions, not user input.\n\n    let safeSql(trusted: String): SqlFragment {\n      let b = new SqlBuilder();\n      b.appendSafe(trusted);\n      b.accumulated\n    }\n\n### Column list helper\n\nBuilds the SELECT column list. If no fields specified, returns `*`.\n\n    let columnListSql(selectFields: List\u003cString\u003e): SqlFragment {\n      if (selectFields.length == 0) {\n        sql\u0022*\u0022\n      } else {\n        let first = safeSql(selectFields[0]);\n        var result = sql\u0022\u0024{first}\u0022;\n        for (var i = 1; i \u003c selectFields.length; i = i + 1) {\n          let col = safeSql(selectFields[i]);\n          result = sql\u0022\u0024{result}, \u0024{col}\u0022;\n        }\n        result\n      }\n    }\n\n### WHERE clause helper\n\nBuilds a single WHERE condition. The value is untrusted user input —\n`sql\u0022...\u0022` escapes it by type automatically.\n\n    let whereConditionSql(clause: WhereClause, schema: Schema): SqlFragment {\n      let col = safeSql(clause.field);\n      let op = safeSql(validOperator(clause.operator));\n      let fieldInfo = schema.getField(clause.field) orelse panic();\n      if (fieldInfo.fieldType == \u0022Int\u0022) {\n        let intVal = clause.value.toInt32() orelse 0;\n        if (clause.value != intVal.toString()) {\n          sql\u00221 = 0\u0022\n        } else {\n          sql\u0022\u0024{col} \u0024{op} \u0024{intVal}\u0022\n        }\n      } else {\n        let strVal = clause.value;\n        sql\u0022\u0024{col} \u0024{op} \u0024{strVal}\u0022\n      }\n    }\n\n### ORDER BY clause helper\n\n    let orderBySql(clauses: List\u003cOrderClause\u003e): SqlFragment {\n      let first = safeSql(clauses[0].field);\n      let firstDir = if (clauses[0].direction == \u0022desc\u0022) { safeSql(\u0022 DESC\u0022) } else { safeSql(\u0022 ASC\u0022) };\n      var result = sql\u0022\u0024{first}\u0024{firstDir}\u0022;\n      for (var i = 1; i \u003c clauses.length; i = i + 1) {\n        let col = safeSql(clauses[i].field);\n        let dir = if (clauses[i].direction == \u0022desc\u0022) { safeSql(\u0022 DESC\u0022) } else { safeSql(\u0022 ASC\u0022) };\n        result = sql\u0022\u0024{result}, \u0024{col}\u0024{dir}\u0022;\n      }\n      result\n    }\n\n### Full SELECT query builder\n\nAssembles a complete SELECT statement from parts. This is the main pure\nfunction: it takes query state in, returns `SqlFragment` out. Field names\nare validated against the schema — only declared fields pass through\n`safeSql`. Unknown fields are silently dropped, closing the confused deputy\nvector where user-controlled strings could reach `appendSafe`.\n\n    export let toSqlQuery(\n      schema: Schema,\n      selectFields: List\u003cString\u003e,\n      whereClauses: List\u003cWhereClause\u003e,\n      orderClauses: List\u003cOrderClause\u003e,\n      limitValue: Int,\n      offsetValue: Int,\n    ): SqlFragment {\n      let validSelect = selectFields.filter { (f: String): Boolean =\u003e\n        schema.hasField(f)\n      };\n      let validWhere = whereClauses.filter { (c: WhereClause): Boolean =\u003e\n        schema.hasField(c.field)\n      };\n      let validOrder = orderClauses.filter { (c: OrderClause): Boolean =\u003e\n        schema.hasField(c.field)\n      };\n      let table = safeSql(schema.tableName);\n      let cols = columnListSql(validSelect);\n      var result = sql\u0022SELECT \u0024{cols} FROM \u0024{table}\u0022;\n      if (validWhere.length \u003e 0) {\n        var conditions = whereConditionSql(validWhere[0], schema);\n        for (var i = 1; i \u003c validWhere.length; i = i + 1) {\n          let next = whereConditionSql(validWhere[i], schema);\n          conditions = sql\u0022\u0024{conditions} AND \u0024{next}\u0022;\n        }\n        result = sql\u0022\u0024{result} WHERE \u0024{conditions}\u0022;\n      }\n      if (validOrder.length \u003e 0) {\n        let ordering = orderBySql(validOrder);\n        result = sql\u0022\u0024{result} ORDER BY \u0024{ordering}\u0022;\n      }\n      if (limitValue \u003e= 0) {\n        result = sql\u0022\u0024{result} LIMIT \u0024{limitValue}\u0022;\n      }\n      if (offsetValue \u003e 0) {\n        result = sql\u0022\u0024{result} OFFSET \u0024{offsetValue}\u0022;\n      }\n      result\n    }\n\n### INSERT statement builder\n\nGenerates an INSERT statement from a schema and a map of field values.\nField names come from the schema (trusted). Values are escaped via\n`sql\u0022...\u0022` by type.\n\n    export let toInsertSql(\n      schema: Schema,\n      values: Map\u003cString, String\u003e,\n    ): SqlFragment {\n      let table = safeSql(schema.tableName);\n      let fieldList = schema.fields.filter { (f: Field): Boolean =\u003e\n        values.has(f.name)\n      };\n      if (fieldList.length == 0) {\n        return sql\u0022\u0022;\n      }\n      let colNames = columnListSql(\n        fieldList.map { (f: Field): String =\u003e f.name }\n      );\n      let firstVal = values.getOr(fieldList[0].name, \u0022\u0022);\n      var vals = if (fieldList[0].fieldType == \u0022Int\u0022) {\n        let iv = firstVal.toInt32() orelse 0;\n        sql\u0022\u0024{iv}\u0022\n      } else {\n        sql\u0022\u0024{firstVal}\u0022\n      };\n      for (var i = 1; i \u003c fieldList.length; i = i + 1) {\n        let val = values.getOr(fieldList[i].name, \u0022\u0022);\n        if (fieldList[i].fieldType == \u0022Int\u0022) {\n          let iv = val.toInt32() orelse 0;\n          vals = sql\u0022\u0024{vals}, \u0024{iv}\u0022;\n        } else {\n          vals = sql\u0022\u0024{vals}, \u0024{val}\u0022;\n        }\n      }\n      sql\u0022INSERT INTO \u0024{table} (\u0024{colNames}) VALUES (\u0024{vals})\u0022\n    }\n\n## SQL Generation Tests\n\n### Basic SELECT\n\n    test(\u0022toSql: select all\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n### SELECT with specific columns\n\n    test(\u0022toSql: select columns\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).select([\u0022name\u0022, \u0022age\u0022]);\n      assert(q.toSql().toString() == \u0022SELECT name, age FROM users\u0022);\n    }\n\n### WHERE with string value\n\n    test(\u0022toSql: where string\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### WHERE with integer value\n\n    test(\u0022toSql: where int\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE age \u003e= 18\u0022);\n    }\n\n### SQL injection protection\n\nThe Bobby Tables attack string is safely escaped — single quotes are doubled.\n\n    test(\u0022toSql: SQL injection blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let bobby = \u0022Robert'); DROP TABLE users;--\u0022;\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, bobby);\n      let result = q.toSql().toString();\n      assert(result == \u0022SELECT * FROM users WHERE name = 'Robert''); DROP TABLE users;--'\u0022);\n    }\n\n### Operator normalization\n\nThe `==` operator from the in-memory query API is normalized to SQL `=`.\n\n    test(\u0022toSql: operator normalization\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022==\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### Invalid operator fallback\n\nUnknown operators fall back to `=` for safety.\n\n    test(\u0022toSql: invalid operator fallback\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022LIKE\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### Multiple WHERE clauses\n\n    test(\u0022toSql: multiple where\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .where(\u0022age\u0022, \u0022\u003c\u0022, \u002230\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE age \u003e= 18 AND age \u003c 30\u0022);\n    }\n\n### ORDER BY\n\n    test(\u0022toSql: order by\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).orderBy(\u0022name\u0022, \u0022asc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users ORDER BY name ASC\u0022);\n    }\n\n### ORDER BY descending\n\n    test(\u0022toSql: order by desc\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).orderBy(\u0022age\u0022, \u0022desc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users ORDER BY age DESC\u0022);\n    }\n\n### LIMIT and OFFSET\n\n    test(\u0022toSql: limit\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).limit(10);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users LIMIT 10\u0022);\n    }\n\n    test(\u0022toSql: offset\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).offset(5);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users OFFSET 5\u0022);\n    }\n\n### Complex query\n\n    test(\u0022toSql: complex query\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .select([\u0022name\u0022, \u0022age\u0022])\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .orderBy(\u0022age\u0022, \u0022desc\u0022)\n        .limit(10)\n        .offset(20);\n      assert(q.toSql().toString() ==\n        \u0022SELECT name, age FROM users WHERE age \u003e= 18 ORDER BY age DESC LIMIT 10 OFFSET 20\u0022);\n    }\n\n### Unicode in values\n\n    test(\u0022toSql: unicode escaping\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022Hello 世界\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Hello 世界'\u0022);\n    }\n\n### Embedded quotes in values\n\n    test(\u0022toSql: embedded quotes\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022O'Brien\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'O''Brien'\u0022);\n    }\n\n### Empty string value\n\n    test(\u0022toSql: empty string\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = ''\u0022);\n    }\n\n### INSERT statement\n\n    test(\u0022toInsertSql: basic insert\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u002225\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() == \u0022INSERT INTO users (name, age) VALUES ('Alice', 25)\u0022);\n    }\n\n### INSERT with injection protection\n\n    test(\u0022toInsertSql: injection blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Robert'); DROP TABLE users;--\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() ==\n        \u0022INSERT INTO users (name) VALUES ('Robert''); DROP TABLE users;--')\u0022);\n    }\n\n### toSqlQuery as standalone pure function\n\n    test(\u0022toSqlQuery: standalone\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let result = toSqlQuery(\n        s, [\u0022name\u0022], [new WhereClause(\u0022age\u0022, \u0022\u003e\u0022, \u002221\u0022)],\n        [new OrderClause(\u0022name\u0022, \u0022asc\u0022)], 5, 0,\n      );\n      assert(result.toString() ==\n        \u0022SELECT name FROM users WHERE age \u003e 21 ORDER BY name ASC LIMIT 5\u0022);\n    }\n\n### Adversarial field name protection\n\nField names not in the schema are silently dropped from SQL generation.\nThis prevents confused deputy attacks where user-controlled strings\ncould reach `appendSafe` through field name positions.\n\n    test(\u0022toSql: adversarial field name blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .where(\u00221=1; DROP TABLE users; --\u0022, \u0022=\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n    test(\u0022toSql: adversarial select column blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .select([\u0022name\u0022, \u00221; DROP TABLE users\u0022]);\n      assert(q.toSql().toString() == \u0022SELECT name FROM users\u0022);\n    }\n\n    test(\u0022toSql: adversarial order by blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .orderBy(\u00221; DROP TABLE users\u0022, \u0022asc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n## Security Audit Fix Tests\n\n### Fix #1: Table name validation\n\n    test(\u0022isValidIdentifier: valid names\u0022) {\n      assert(isValidIdentifier(\u0022users\u0022));\n      assert(isValidIdentifier(\u0022user_table\u0022));\n      assert(isValidIdentifier(\u0022Table1\u0022));\n      assert(isValidIdentifier(\u0022_private\u0022));\n      assert(isValidIdentifier(\u0022a\u0022));\n    }\n\n    test(\u0022isValidIdentifier: invalid names\u0022) {\n      assert(!isValidIdentifier(\u0022\u0022));\n      assert(!isValidIdentifier(\u0022users; DROP TABLE\u0022));\n      assert(!isValidIdentifier(\u0022users--\u0022));\n      assert(!isValidIdentifier(\u0022ta ble\u0022));\n      assert(!isValidIdentifier(\u0022table.name\u0022));\n      assert(!isValidIdentifier(\u0022Robert'); DROP TABLE users;--\u0022));\n    }\n\n### Fix #3: Non-numeric value for Int field\n\n    test(\u0022toSql: non-numeric Int value produces always-false\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022age\u0022, \u0022=\u0022, \u0022admin\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE 1 = 0\u0022);\n    }\n\n    test(\u0022in-memory: non-numeric Int value matches nothing\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u00220\u0022),\n      ]));\n      let results = new Query(s, store).where(\u0022age\u0022, \u0022=\u0022, \u0022admin\u0022).all();\n      assert(results.length == 0);\n    }\n\n### Fix #5: LIMIT zero and negative\n\n    test(\u0022toSql: limit zero emits LIMIT 0\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).limit(0);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users LIMIT 0\u0022);\n    }\n\n    test(\u0022in-memory: limit zero returns empty\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n      ]));\n      let results = new Query(s, store).limit(0).all();\n      assert(results.length == 0);\n    }\n\n    test(\u0022in-memory: negative limit clamped to zero\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n      ]));\n      let results = new Query(s, store).limit(-5).all();\n      assert(results.length == 0);\n    }\n\n### Fix #6: Empty insert safety\n\n    test(\u0022toInsertSql: no matching fields returns empty\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022nonexistent\u0022, \u0022value\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() == \u0022\u0022);\n    }\n\n## Demo\n\n    export let main(): Void {\n      console.log(\u0022=== ORMery Demo ===\\n\u0022);\n\n      let userFields = [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n        field(\u0022email\u0022, \u0022String\u0022, false, true),\n      ];\n      let userSchema = schema(\u0022users\u0022, userFields);\n\n      console.log(userSchema.describe());\n      console.log(\u0022\u0022);\n\n      let store = new InMemoryStore();\n\n      let rec1 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u002225\u0022),\n        new Pair(\u0022email\u0022, \u0022alice@example.com\u0022),\n      ]));\n\n      let rec2 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Bob\u0022),\n        new Pair(\u0022age\u0022, \u002230\u0022),\n        new Pair(\u0022email\u0022, \u0022bob@example.com\u0022),\n      ]));\n\n      let rec3 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Charlie\u0022),\n        new Pair(\u0022age\u0022, \u002217\u0022),\n        new Pair(\u0022email\u0022, \u0022charlie@example.com\u0022),\n      ]));\n\n      console.log(\u0022Inserted 3 users:\u0022);\n      console.log(\u0022  \u0024{rec1.describe()}\u0022);\n      console.log(\u0022  \u0024{rec2.describe()}\u0022);\n      console.log(\u0022  \u0024{rec3.describe()}\u0022);\n      console.log(\u0022\u0022);\n\n      console.log(\u0022=== In-Memory Queries ===\\n\u0022);\n\n      console.log(\u0022All users:\u0022);\n      let allUsers = new Query(userSchema, store).all();\n      for (let u of allUsers) {\n        console.log(\u0022  \u0024{u.describe()}\u0022);\n      }\n      console.log(\u0022\u0022);\n\n      console.log(\u0022Adults (age \u003e= 18):\u0022);\n      let adults = new Query(userSchema, store)\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .all();\n      for (let u of adults) {\n        console.log(\u0022  \u0024{u.describe()}\u0022);\n      }\n      console.log(\u0022\u0022);\n\n      console.log(\u0022=== SQL Generation (secure-composition) ===\\n\u0022);\n\n      let q1 = new Query(userSchema, store);\n      console.log(\u0022SELECT all: \u0024{q1.toSql().toString()}\u0022);\n\n      let q2 = new Query(userSchema, store)\n        .select([\u0022name\u0022, \u0022age\u0022])\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .orderBy(\u0022age\u0022, \u0022desc\u0022)\n        .limit(10);\n      console.log(\u0022Complex:    \u0024{q2.toSql().toString()}\u0022);\n\n      let bobby = \u0022Robert'); DROP TABLE users;--\u0022;\n      let q3 = new Query(userSchema, store)\n        .where(\u0022name\u0022, \u0022=\u0022, bobby);\n      console.log(\u0022Injection:  \u0024{q3.toSql().toString()}\u0022);\n\n      let insertVals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022O'Malley\u0022),\n        new Pair(\u0022age\u0022, \u002242\u0022),\n      ]);\n      console.log(\u0022INSERT:     \u0024{toInsertSql(userSchema, insertVals).toString()}\u0022);\n\n      console.log(\u0022\\n=== Demo Complete ===\u0022);\n    }\n" ], "names": [ "SqlFragment", "SqlBuilder", "SafeHtml", "SafeHtmlBuilder", "console#737", "temperKeywords", "temperTypes", "compareInt", "recordValue", "operator", "clauseValue", "return", "t#4028", "t#2376", "t#2378", "fn", "rv", "rv#5874", "cv", "cv#5875", "compareString", "safeSql", "trusted", "b", "columnListSql", "selectFields", "t#4009", "t#4012", "t#4014", "t#4016", "t#4017", "t#4018", "t#4020", "t#4024", "first", "result", "i", "col", "validOperator", "op", "whereConditionSql", "WhereClause", "clause", "Schema", "schema", "t#3990", "t#3993", "t#4001", "t#2320", "t#3981", "t#3983", "t#3985", "Field", "t#2316", "fieldInfo", "intVal", "intVal#5876", "strVal", "orderBySql", "OrderClause", "clauses", "t#3961", "t#3962", "t#3967", "t#3969", "t#3973", "t#3974", "t#3975", "t#3980", "t#2303", "t#3957", "firstDir", "t#3963", "t#3966", "dir", "toSqlQuery", "whereClauses", "orderClauses", "limitValue", "offsetValue", "t#3924", "t#3925", "t#3926", "t#3927", "t#3929", "t#3933", "t#3934", "t#3938", "t#3941", "t#3945", "t#3946", "t#3950", "t#3951", "t#3955", "f", "validSelect", "c", "t#3902", "validWhere", "t#3900", "validOrder", "t#3914", "table", "cols", "t#3917", "t#3922", "conditions", "next", "ordering", "field", "name", "fieldType", "primaryKey", "nullable", "isValidIdentifier", "t#3781", "this", "index", "codePoint", "tableName", "fields", "idField", "allFields", "t#3776", "toInsertSql", "values", "t#3724", "t#3726", "t#3730", "t#3733", "t#3736", "t#3740", "t#3742", "t#3743", "t#3745", "t#3746", "t#3748", "t#3752", "t#3756", "t#3757", "t#3761", "t#3762", "t#2047", "t#2058", "t#2065", "t#2066", "t#3720", "fieldList", "colNames", "firstVal", "iv", "iv#5882", "vals", "val", "main", "userFields", "userSchema", "t#3304", "InMemoryStore", "store", "Record", "rec1", "rec2", "rec3", "t#3324", "t#3326", "t#3328", "allUsers", "Query", "u", "t#3298", "adults", "t#3296", "q1", "t#3348", "q2", "t#3356", "bobby", "q3", "t#3361", "insertVals", "t#3367", "TokenType", "classifyWord", "word", "n", "el", "kw", "tp", "highlightWord", "t#3275", "tokenType", "Token", "token", "highlightLine", "line", "t#3263", "t#3266", "t#3267", "t#3270", "t#3274", "words", "highlightSource", "source", "t#3249", "t#3252", "t#3253", "t#3256", "t#3260", "lines", "highlightBlock", "highlighted", "t#3242" ], "mappings": "A;A,kB,W;A;A,kB,U;A;A;A,mB,Q;A,mB,e;A;A;A;A;A;A;A;A;A;A;ADMiB,yBDAAI,WDAA,CDAA;AD0Cb,gBDKC,ADLmB,KDAY,ADAZ,ODAY,CDAA,ADAhC,CDAAC,mBDKC;ADED,gBDKC,ADLgB,KDAY,ADAZ,ODAY,CDAA,ADA7B,CDAAC,gBDKC,CDAA;ADgSD,UDaC,ADb2E,QDAO,ADA/E,CDAAC,eDAU,CDAoB,ADAN,MDAM,ADAnB,CDAAC,gBDAmB,CDAkB,ADAN,ODAM,ADAhB,CDAAC,aDAgB,CDAqB,ADAN,ODAM,ADAnB,CDAAC,gBDAmB,CDAW,EDAA;ADAR,eDAO,ADAP,CDAAC,WDAA,CDG1C;ADAb,cDAa,ADAb,CDAAC,MDAa,CDAA;ADFvB,WDAqB,ADArB,CDAAC,MDAqB,CDCA;ADArB,WDAqB,ADArB,CDAAC,MDAqB,CDAA;ADFoD,QDAAC,ODanF,CDAA,ADbmF,EDC3C;ADAvC,eDAuC,ADAnC,CDAAC,ODAE,CDAiC;ADA9B,gBDAAC,ODAA;ADAA;ADAA,gBDAAJ,MDAA,EDAqB,ADArB,KDAqB,CDAA,ADArB,WDAqB,CDAA,ADArBL,gBDAW,CDAU,CDAA;ADArB,gBDAAS,ODAA,EDAqB,ADArB,CDAAJ,MDAqB;ADAA,aDAQ,QDAC,ADAD,gBDAC,ADAD,UDAC,CDAA,ADAD;ADAA,gBDAAI,ODAA,EDAC,ADAD,EDAC;ADAA;ADAA,YDAAD,ODAA,GDAAC,ODAA,CDCA;ADAvC,eDAuC,ADAnC,CDAAC,ODAE,CDAiC;ADA9B,gBDAAC,ODAA;ADAA;ADAA,gBDAAL,MDAA,EDAqB,ADArB,KDAqB,CDAA,ADArB,WDAqB,CDAA,ADArBJ,gBDAW,CDAU,CDAA;ADArB,gBDAAS,ODAA,EDAqB,ADArB,CDAAL,MDAqB;ADAA,aDAQ,QDAC,ADAD,gBDAC,ADAD,UDAC,CDAA,ADAD;ADAA,gBDAAK,ODAA,EDAC,ADAD,EDAC;ADAA;ADAA,YDAAD,ODAA,GDAAC,ODAA;ADCpB,YDAAP,MDAA,EDAa,ADAb,QDAa,CDAA,ADAb,QDAa,CDAA,ADAbM,ODAE,CDAW,CDAA;ADAhC,gBDAI,CDA4B,ADA5BR,gBDAW,CDAA,ADAX,MDA4B,CDAA,ADAbE,MDAa,EDAE;ADAE,gBDAAD,WDAY,ADAZ,EDAY,ADAL,MDAK,CDAA;ADAZ,sBDAAI,ODAY;ADAA;ADChD,gBDCE,ADDIN,aDAQ,CDCZ,MDAI,CDAA,ADAJ,IDAI,EDAI;ADAA,gBDAAE,WDAA,EDAQ,ADAR,CDAAK,ODAE,ADAF,GDAQ,ADAF,CDAAE,ODAE;ADAA,kBDAA,ADDlB,KDEE,ADFIT,aDAQ,CDEZ,MDAI,CDAA,ADAJ,IDAI,EDAI;ADAA,gBDAAE,WDAA,EDAQ,ADAR,CDAAK,ODAE,ADAF,GDAQ,ADAF,CDAAE,ODAE;ADAA,kBDAA,ADFlB,KDGE,ADHIT,aDAQ,CDGZ,MDAG,CDAA,ADAH,GDAG,EDAI;ADAA,gBDAAE,WDAA,EDAO,ADAP,CDAAK,ODAE,ADAF,EDAO,ADAF,CDAAE,ODAE;ADAA,kBDAA,ADHhB,KDIE,ADJIT,aDAQ,CDIZ,MDAG,CDAA,ADAH,GDAG,EDAI;ADAA,gBDAAE,WDAA,EDAO,ADAP,CDAAK,ODAE,ADAF,EDAO,ADAF,CDAAE,ODAE;ADAA,kBDAA,ADJhB,KDKE,ADLIT,aDAQ,CDKZ,MDAI,CDAA,ADAJ,IDAI,EDAI;ADAA,gBDAAE,WDAA,EDAQ,ADAR,CDAAK,ODAE,ADAF,GDAQ,ADAF,CDAAE,ODAE;ADAA,kBDAA,ADLlB,KDME,ADNIT,aDAQ,CDMZ,MDAI,CDAA,ADAJ,IDAI,EDAI;ADAA,gBDAAE,WDAA,EDAQ,ADAR,CDAAK,ODAE,ADAF,GDAQ,ADAF,CDAAE,ODAE;ADAA,kBDCR;ADAA,gBDAAP,WDAA,EDAK,ADAL,MDAK;ADAA;ADCd;ADCF,cDAA,ADb2E,CDAAA,WDAA;ADa3E;ADED,UDUC,ADV8E,QDAO,ADAlF,CDAAS,kBDAa,CDAoB,ADAN,MDAM,ADAnB,CDAAZ,gBDAmB,CDAkB,ADAN,ODAM,ADAhB,CDAAC,aDAgB,CDAqB,ADAN,ODAM,ADAnB,CDAAC,gBDAmB,CDAW,EDAA;ADAR,eDAO,ADAP,CDAAC,WDAA;ADC7E,YDCE,ADDIF,aDAQ,CDCZ,MDAI,CDAA,ADAJ,IDAI,EDAI;ADAA,YDAAE,WDAA,EDA0B,ADA1B,CDAAH,gBDAW,CDAA,ADAX,MDA0B,CDAA,ADAXE,gBDAW;ADAA,cDAA,ADDpC,KDEE,ADFID,aDAQ,CDEZ,MDAI,CDAA,ADAJ,IDAI,EDAI;ADAA,YDAAE,WDAA,EDA0B,ADA1B,EDA0B,ADA1BH,gBDAW,CDAA,ADAX,MDA0B,CDAA,ADAXE,gBDAW;ADAA,cDAA,ADFpC,KDGE,ADHID,aDAQ,CDGZ,MDAG,CDAA,ADAH,GDAG,EDAI;ADAA,YDAAE,WDAA,EDAyB,ADAzB,CDAAH,gBDAW,CDAA,ADAX,SDAyB,CDAA,ADAXE,gBDAW,CDAA,ADAzB,EDAyB,ADAzB,EDAyB;ADAA,cDAA,ADHlC,KDIE,ADJID,aDAQ,CDIZ,MDAG,CDAA,ADAH,GDAG,EDAI;ADAA,YDAAE,WDAA,EDAyB,ADAzB,CDAAH,gBDAW,CDAA,ADAX,SDAyB,CDAA,ADAXE,gBDAW,CDAA,ADAzB,EDAyB,ADAzB,EDAyB;ADAA,cDAA,ADJlC,KDKE,ADLID,aDAQ,CDKZ,MDAI,CDAA,ADAJ,IDAI,EDAI;ADAA,YDAAE,WDAA,EDA0B,ADA1B,CDAAH,gBDAW,CDAA,ADAX,SDA0B,CDAA,ADAXE,gBDAW,CDAA,ADA1B,GDA0B,ADA1B,EDA0B;ADAA,cDAA,ADLpC,KDME,ADNID,aDAQ,CDMZ,MDAI,CDAA,ADAJ,IDAI,EDAI;ADAA,YDAAE,WDAA,EDA0B,ADA1B,CDAAH,gBDAW,CDAA,ADAX,SDA0B,CDAA,ADAXE,gBDAW,CDAA,ADA1B,GDA0B,ADA1B,EDA0B;ADAA,cDC1B;ADAA,YDAAC,WDAA,EDAK,ADAL,MDAK;ADAA;ADEhB,cDAA,ADV8E,CDAAA,WDAA;ADU9E;ADiCD,UDIC,ADJ6B,CDAAX,WDAW,ADArC,CDAAqB,YDAO,CDAgB,ADAN,MDAM,ADAf,CDAAC,YDAe,CDAe,EDChB;ADAxB,QDAArB,UDAwB,ADApB,CDAAsB,MDAC,EDAG,IDAI,CDAAtB,UDAU,EDAE;ADCxB,QDAAsB,MDAC,CDAC,UDAU,CDACD,YDAO,CDAC;ADCrB,eDAAC,MDAC,CDAY;ADAA;ADOf,UDYC,ADZ8C,CDAAvB,WDAW,ADAtD,CDAAwB,kBDAa,CDA2B,ADAZ,IDAY,ADAZ,ODAY,CDAA,ADA1B,CDAAC,iBDA0B,CDAe,EDAA;ADAZ,QDAAzB,WDAW,ADAX,CDAAW,WDAA;ADE3C,QDAAV,UDAA,CDAAyB,MDAA,CDEmC;ADAf,cDAe,ADAf,CDAAC,MDAe;ADCtB,QDAA1B,UDAA,CDAA2B,MDAA;ADAA,QDAA5B,WDAA,CDAA6B,MDAA,CDC0B;ADAnB,WDAmB,ADAnB,CDAAC,MDAmB,CDCJ;ADAf,cDAe,ADAf,CDAAC,MDAe;ADCxB,QDAA9B,UDAA,CDAA+B,MDAA;ADAA,QDAAhC,WDAA,CDAAiC,MDAA,CDAA;ADPb,YDAIR,iBDAY,CDAA,ADAZ,IDAmB,EDAA,ADAnB,GDAwB,ADAD,EDAC,CDAE;ADC5B,YDAAC,MDAA,ODAAzB,UDAG,EDAA,ADAH;ADAI,YDAAyB,MDAA,eDAC,EDAA;ADAL,YDAAf,WDAA,GDAAe,MDAA;ADAA,SDCD,KDAM;ADCe,YDAAC,MDAA,EDAe,ADAf,KDAe,CDAA,ADAf,ODAe,CDAA,ADAfF,iBDAY,CDAC,EDAC,CDAC,CDAA;ADAnC,YDAAzB,WDAoC,ADAhC,CDAAkC,UDAK,EDAG,aDAwB,CDAA,ADAxBb,YDAO,CDACM,MDAe,CDAC;ADCvB,YDAAC,MDAA,ODAA3B,UDAG,EDAA,ADAH;ADAM,YDAA2B,MDAA,gBDAAM,UDAK,EDAA;ADAX,YDAAL,MDAA,GDAAD,MDAA,kBDAA;ADAV,YDAA5B,WDAuB,ADAtB,CDAAmC,WDAM,EDAG,CDAAN,MDAa,CDCZ;ADAN,eDAM,ADAL,CDAAO,MDAC,EDAG,EDAC,CDAA;ADAd,wBDAoD,EDAA;ADAhC,gBDAAN,MDAA,EDAmB,ADAnB,CDAAL,iBDAY,CDAA,ADAZ,IDAmB,GDAA;ADAvB,oBDAAW,MDAC,ADAD,GDAuB,ADAnB,CDAAN,MDAmB,CDAA,ADAvB;ADAuB;ADAA;ADCnB,gBDAAC,MDAA,EDAe,ADAf,KDAe,CDAA,ADAf,ODAe,CDAA,ADAfN,iBDAY,CDAC,CDAAW,MDAC,CDAC,CDAA;ADAjC,gBDAApC,WDAkC,ADA9B,CDAAqC,QDAG,EDAG,aDAwB,CDAA,ADAxBhB,YDAO,CDACU,MDAe,CDAC;ADCzB,gBDAAC,MDAA,ODAA/B,UDAG,EDAA,ADAH;ADAM,gBDAA+B,MDAA,gBDAAG,WDAM;ADAC,gBDAAH,MDAA,gBDAE;ADAE,gBDAAA,MDAA,gBDAAK,QDAG,EDAA;ADApB,gBDAAJ,MDAA,GDAAD,MDAA,kBDAA;ADAT,gBDAAG,WDAM,ADAN,EDA+B,ADAtB,CDAAF,MDAsB,CDAA;ADFQ,gBDAAG,MDAC,ADAD,EDAS,ADAL,CDAAA,MDAC,ADAD,EDAK,ADAD,EDAC;ADAA,aDGjD;ADNI,YDAAzB,WDAA,EDQN,ADRM,CDAAwB,WDQN;ADAA;ADCF,cDAA,ADZ8C,CDAAxB,WDAA;ADY9C,KDAA;ADzCD,UDYC,ADZ8B,ODAM,ADAjC,CDAA2B,kBDAa,CDAW,ADAN,MDAM,ADAV,CDAAC,ODAU,CDAU,EDAA;ADAP,cDAM,ADAN,CDAA5B,WDAA;ADC7B,YDCE,ADDI4B,ODAE,CDCN,MDAG,CDAA,ADAH,GDAG,EDAI;ADAA,YDAA5B,WDAA,EDAG,ADAH,IDAG;ADAA,cDAA,ADDZ,KDEE,ADFI4B,ODAE,CDEN,MDAI,CDAA,ADAJ,IDAI,EDAI;ADAA,YDAA5B,WDAA,EDAG,ADAH,IDAG;ADAA,cDAA,ADFb,KDGE,ADHI4B,ODAE,CDGN,MDAI,CDAA,ADAJ,IDAI,EDAI;ADAA,YDAA5B,WDAA,EDAI,ADAJ,KDAI;ADAA,cDAA,ADHd,KDIE,ADJI4B,ODAE,CDIN,MDAI,CDAA,ADAJ,IDAI,EDAI;ADAA,YDAA5B,WDAA,EDAI,ADAJ,KDAI;ADAA,cDAA,ADJd,KDKE,ADLI4B,ODAE,CDKN,MDAG,CDAA,ADAH,GDAG,EDAI;ADAA,YDAA5B,WDAA,EDAG,ADAH,IDAG;ADAA,cDAA,ADLZ,KDME,ADNI4B,ODAE,CDMN,MDAG,CDAA,ADAH,GDAG,EDAI;ADAA,YDAA5B,WDAA,EDAG,ADAH,IDAG;ADAA,cDAA,ADNZ,KDOE,ADPI4B,ODAE,CDON,MDAI,CDAA,ADAJ,IDAI,EDAI;ADAA,YDAA5B,WDAA,EDAI,ADAJ,KDAI;ADAA,cDAA,ADPd,KDQE,ADRI4B,ODAE,CDQN,MDAI,CDAA,ADAJ,IDAI,EDAI;ADAA,YDAA5B,WDAA,EDAI,ADAJ,KDAI;ADAA,cDCJ;ADAA,YDAAA,WDAA,EDAG,ADAH,IDAG;ADAA;ADEd,cDAA,ADZ8B,CDAAA,WDAA;ADY9B;ADoCD,UDeC,ADf2D,CDAAX,WDAW,ADAnE,CDAAwC,sBDAiB,CDAoB,ADAXC,WDAW,ADAnB,CDAAC,WDAmB,CDAgB,ADAN,CDAAC,MDAM,ADAd,CDAAC,WDAc,CDAe,EDAA;ADAZ,QDAA5C,WDAW,ADAX,CDAAW,WDAA;ADOtD,QDAAV,UDAA,CDAA4C,MDAA;ADEA,QDAA5C,UDAA,CDAA6C,MDAA;ADIF,QDAA7C,UDAA,CDAA8C,MDAA,CDAA;ADRa,WDAsB,ADAtB,CDAAC,MDAsB,CDAA;ADJnB,cDAY,ADAZ,CDAAC,MDAY,EDAA,ADAZ,CDAAP,WDAM,CDAM,WDAA;ADA9B,QDAA1C,WDA+B,ADA3B,CDAAqC,QDAG,EDAG,aDAqB,CDAA,ADArBhB,YDAO,CDAC4B,MDAY,CDAC,CDCe;ADAf,cDAe,ADAf,CDAAC,MDAe,EDAA,ADAf,CDAAR,WDAM,CDAS,cDAA;ADA9C,QDAA1C,WDAgD,ADA5C,CDAAuC,ODAE,EDAG,aDAuC,CDAA,ADAvClB,YDAO,CDAC,YDA8B,CDAA,ADA9BiB,kBDAa,CDACY,MDAe,CDAC,CDAC,CDCJ;ADAZ,cDAY,ADAZ,CDAAC,MDAY,EDAA,ADAZ,CDAAT,WDAM,CDAM,WDAA;ADA5B,QDAAU,KDA6B,ADA7B,CDAAC,MDA6B,CDAA;ADA7B,QDAAA,MDAA,EDA6B,ADA7B,CDAAT,WDAM,CDAC,QDAQ,CDACO,MDAY,CDAC,CDAA;ADA7C,QDAAC,KDA4D,ADAxD,CDAAE,cDAS,EDAG,CDAAD,MDA6B;ADC7C,YDAIC,cDAS,CDAU,eDAA,ADAnB,MDA4B,CDAA,ADAL,KDAK,EDAE,EDCY;ADA5C,eDA4C,ADAxC,CDAAC,WDAM,CDAkC;ADA/B,gBDAAC,WDAA;ADAA;ADAA,gBDAAR,MDAA,EDAsB,ADAtB,KDAsB,CDAA,ADAtB,WDAsB,CDAA,ADAtBN,WDAM,CDAM,WDAU,CDAA;ADAtB,gBDAAc,WDAA,EDAsB,ADAtB,CDAAR,MDAsB;ADAA,aDAQ,QDAC,ADAD,gBDAC,ADAD,UDAC,CDAA,ADAD;ADAA,gBDAAQ,WDAA,EDAC,ADAD,EDAC;ADAA;ADAA,YDAAD,WDAA,GDAAC,WDAA;ADC5C,gBDAI,CDAiC,ADAjCd,WDAM,CDAM,WDAA,ADAZ,MDAiC,CDAA,ADAjB,ODAiB,CDAA,ADAjB,QDAiB,CDAA,ADAjBa,WDAM,CDAW,EDAE;ADCrC,gBDAAV,MDAA,ODAA5C,UDAG,EDAA,ADAH;ADAI,gBDAA4C,MDAA,mBDAK,EDAA;ADAT,gBDAAlC,WDAA,GDAAkC,MDAA;ADAA,aDCD,KDAM;ADCL,gBDAAC,MDAA,ODAA7C,UDAG,EDAA,ADAH;ADAM,gBDAA6C,MDAA,gBDAAT,QDAG;ADAC,gBDAAS,MDAA,eDAC;ADAE,gBDAAA,MDAA,gBDAAP,ODAE;ADAC,gBDAAO,MDAA,eDAC;ADAE,gBDAAA,MDAA,aDAAS,WDAM,EDAA;ADAzB,gBDAA5C,WDAA,GDAAmC,MDAA;ADAA;ADCD,SDCF,KDAM,EDCoB;ADAzB,kBDAyB,ADArB,CDAAW,WDAM,EDAG,CDAAf,WDAM,CDAM;ADCzB,YDAAK,MDAA,ODAA9C,UDAG,EDAA,ADAH;ADAM,YDAA8C,MDAA,gBDAAV,QDAG;ADAC,YDAAU,MDAA,eDAC;ADAE,YDAAA,MDAA,gBDAAR,ODAE;ADAC,YDAAQ,MDAA,eDAC;ADAE,YDAAA,MDAA,cDAAU,WDAM,EDAA;ADAzB,YDAA9C,WDAA,GDAAoC,MDAA;ADAA;ADEH,cDAA,ADf2D,CDAApC,WDAA;ADe3D;ADID,UDUC,ADV2C,CDAAX,WDAW,ADAnD,CDAA0D,eDAU,CDA2B,ADAjB,IDAiB,ADAjB,CDAAC,WDAiB,CDAA,ADA1B,CDAAC,YDA0B,CDAe,EDEe;ADAhB,QDAA5D,WDAgB,ADAhB,CDAA6D,MDAgB,CDAyB;ADAf,QDAA7D,WDAe,ADAf,CDAA8D,MDAe,CDE5D;ADAd,WDAc,ADAd,CDAAC,MDAc,CDCE;ADAhB,cDAgB,ADAhB,CDAAC,MDAgB,CDC8B;ADAhB,QDAAhE,WDAgB,ADAhB,CDAAiE,MDAgB,CDAyB;ADAf,QDAAjE,WDAe,ADAf,CDAAkE,MDAe;ADChF,QDAAjE,UDAA,CDAAkE,MDAA;ADAA,QDAAnE,WDAA,CDAAoE,MDAA,CDAA;ADDqC,QDAApE,WDAoB,ADApB,CDAAqE,MDAoB,CDAA;ADLhD,cDAgB,ADAhB,CDAAC,MDAgB,EDAA,ADAhB,KDAU,CDAA,ADAV,ODAU,CDAA,ADAVV,YDAO,CDAC,EDAC,CDAC,CDAM,WDAA;ADApC,QDAA5D,WDAqC,ADAjC,CDAAkC,UDAK,EDAG,aDAyB,CDAA,ADAzBb,YDAO,CDACiD,MDAgB,CDAC,CDC2D;ADAhG,QDAAtE,WDAgG,ADA5F,CDAAuE,aDAQ,CDAoF;ADAjF,YDAI,IDAU,CDAA,ADAV,ODAU,CDAA,ADAVX,YDAO,CDAC,EDAC,CDAC,CDAU,eDAA,ADApB,MDA8B,CDAA,ADAN,MDAM,EDAE;ADAE,YDAAC,MDAA,EDAgB,ADAhB,aDAgB,CDAA,ADAhBxC,YDAO,CDAC,ODAO,CDAC,CDAA;ADAhB,YDAAkD,aDAA,EDAgB,ADAhB,CDAAV,MDAgB;ADAA,SDAE,KDAM;ADAE,YDAAC,MDAA,EDAe,ADAf,aDAe,CDAA,ADAfzC,YDAO,CDAC,MDAM,CDAC,CDAA;ADAf,YDAAkD,aDAA,EDAe,ADAf,CDAAT,MDAe;ADAA;ADCjF,QDAA7D,UDAA,CDAAuE,MDAA,ODAAvE,UDAG,EDAA,ADAH;ADAM,QDAAuE,MDAA,gBDAAtC,UDAK;ADAG,QDAAsC,MDAA,gBDAAD,aDAQ,EDAA;ADAtB,QDAAvE,WDAA,CDAAyE,MDAA,GDAAD,MDAA,kBDAA;ADAV,QDAAxE,WDAkC,ADAjC,CDAAmC,WDAM,EDAG,CDAAsC,MDAwB,CDCvB;ADAN,WDAM,ADAL,CDAArC,MDAC,EDAG,EDAC,CDAA;ADAd,oBDA+C,EDAA;ADA3B,YDAA2B,MDAA,EDAc,ADAd,CDAAH,YDAO,CDAA,ADAP,IDAc,GDAA;ADAlB,gBDAAxB,MDAC,ADAD,GDAkB,ADAd,CDAA2B,MDAc,CDAA,ADAlB;ADAkB;ADAA;ADCd,YDAAC,MDAA,EDAgB,ADAhB,KDAU,CDAA,ADAV,ODAU,CDAA,ADAVJ,YDAO,CDAC,CDAAxB,MDAC,CDAC,CDAM,WDAA;ADAlC,YDAApC,WDAmC,ADA/B,CDAAqC,QDAG,EDAG,aDAyB,CDAA,ADAzBhB,YDAO,CDAC2C,MDAgB,CDAC;ADCzB,gBDAI,IDAU,CDAA,ADAV,ODAU,CDAA,ADAVJ,YDAO,CDAC,CDAAxB,MDAC,CDAC,CDAU,eDAA,ADApB,MDA8B,CDAA,ADAN,MDAM,EDAE;ADAE,gBDAA6B,MDAA,EDAgB,ADAhB,aDAgB,CDAA,ADAhB5C,YDAO,CDAC,ODAO,CDAC,CDAA;ADAhB,gBDAAgD,MDAA,EDAgB,ADAhB,CDAAJ,MDAgB;ADAA,aDAE,KDAM;ADAE,gBDAAC,MDAA,EDAe,ADAf,aDAe,CDAA,ADAf7C,YDAO,CDAC,MDAM,CDAC,CDAA;ADAf,gBDAAgD,MDAA,EDAe,ADAf,CDAAH,MDAe;ADAA,aDAE;ADA3F,YDAAlE,WDA2F,ADAvF,CDAA0E,QDAG,EDAG,CDAAL,MDAiF;ADClF,YDAAF,MDAA,ODAAlE,UDAG,EDAA,ADAH;ADAM,YDAAkE,MDAA,gBDAAhC,WDAM;ADAC,YDAAgC,MDAA,gBDAE;ADAE,YDAAA,MDAA,gBDAA9B,QDAG;ADAG,YDAA8B,MDAA,gBDAAO,QDAG,EDAA;ADA1B,YDAAN,MDAA,GDAAD,MDAA,kBDAA;ADAT,YDAAhC,WDAM,ADAN,EDAqC,ADA5B,CDAAiC,MDA4B,CDAA;ADHH,YDAAhC,MDAC,ADAD,EDAS,ADAL,CDAAA,MDAC,ADAD,EDAK,ADAD,EDAC;ADAA;ADK7C,eDAAD,WDAM;ADAA;ADWD,iBDuCN,ADhCE,CDAAnC,WDAW,ADPH,CDAA2E,UDAU,CDCL,ADANhC,MDAM,ADAd,CDAAC,WDAc,CDCY,ADAZ,KDAY,ADAZ,ODAY,CDAA,ADA1B,CDAAnB,iBDA0B,CDCK,ADAjB,KDAiB,ADAjB,CDAAgB,WDAiB,CDAA,ADA/B,CDAAmC,iBDA+B,CDCA,ADAjB,KDAiB,ADAjB,CDAAjB,WDAiB,CDAA,ADA/B,CDAAkB,iBDA+B,CDChB,ADAH,IDAG,ADAf,CDAAC,eDAe,CDCC,ADAH,IDAG,ADAhB,CDAAC,gBDAgB,CDCH,EDcqC;ADAb,QDAAtC,WDAa,ADAb,CDAAuC,MDAa,CDAA;ADA/B,QDAAhF,WDAwC,ADAxC,CDAAiF,MDAwC,CDCpB;ADAjB,WDAiB,ADAjB,CDAAC,MDAiB,CDCO;ADAb,QDAAzC,WDAa,ADAb,CDAA0C,MDAa;ADC7B,QDAAlF,UDAA,CDAAmF,MDAA;ADAA,QDAApF,WDAA,CDAAqF,MDAA;ADEN,QDAApF,UDAA,CDAAqF,MDAA;ADAA,QDAAtF,WDAA,CDAAuF,MDAA;ADIA,QDAAtF,UDAA,CDAAuF,MDAA;ADAA,QDAAxF,WDAA,CDAAyF,MDAA;ADGA,QDAAxF,UDAA,CDAAyF,MDAA;ADAA,QDAA1F,WDAA,CDAA2F,MDAA;ADGA,QDAA1F,UDAA,CDAA2F,MDAA;ADAA,QDAA5F,WDAA,CDAA6F,MDAA,CDAA;AD5B2B,0BDAA9E,QDAA,EDAG,CDAA+E,MDAC,ADAJ,GDCpC,CDAAlD,WDAM,CDAC,QDAQ,CDACkD,MDAC,CDAC,ADDkB,CDAA;ADAtC,YDEC,ADFD,ODEC,CDAA,ADFG,CDAAC,gBDAW,EDAG,KDEjB,CDAA,ADFiB,aDEjB,CDAA,ADFiBtE,iBDAY,CDAQ,CDAAV,QDErC;ADCoC,kBDAA0B,WDAA,EDAA1B,QDAA,EDAG,CDAAiF,MDAC,ADAJ,GDCnC,EDAuB;ADAP,kBDAO,ADAP,CDAAC,MDAO,EDAA,ADAP,CDAAD,MDAC,CDAM,WDAA;ADAvB,mBDAApD,WDAM,CDAC,QDAQ,CDACqD,MDAO,CDAC;ADAA,SDAA,ADDW,CDAA;ADArC,YDEC,ADFD,CDAAxD,WDEC,CDAA,ADFG,CDAAyD,eDAU,EDAG,KDEhB,CDAA,ADFgB,aDEhB,CDAA,ADFgBtB,iBDAY,CDAQ,CDAA7D,QDEpC;ADCoC,kBDAA4C,WDAA,EDAA5C,QDAA,EDAG,CDAAiF,MDAC,ADAJ,GDCnC,EDAuB;ADAP,kBDAO,ADAP,CDAAG,MDAO,EDAA,ADAP,CDAAH,MDAC,CDAM,WDAA;ADAvB,mBDAApD,WDAM,CDAC,QDAQ,CDACuD,MDAO,CDAC;ADAA,SDAA,ADDW,CDAA;ADArC,YDEC,ADFD,CDAAxC,WDEC,CDAA,ADFG,CDAAyC,eDAU,EDAG,KDEhB,CDAA,ADFgB,aDEhB,CDAA,ADFgBvB,iBDAY,CDAQ,CDAA9D,QDEpC,EDCmC;ADAhB,cDAgB,ADAhB,CDAAsF,MDAgB,EDAA,ADAhB,CDAAzD,WDAM,CDAU,eDAA;ADApC,QDAA5C,WDAqC,ADAjC,CDAAsG,UDAK,EDAG,aDAyB,CDAA,ADAzBjF,YDAO,CDACgF,MDAgB,CDAC,CDCA;ADArC,QDAArG,WDAqC,ADAjC,CDAAuG,SDAI,EDAG,aDA0B,CDAA,ADA1B/E,kBDAa,CDACuE,gBDAW,CDAC;ADCxB,QDAA9F,UDAA,CDAAuG,MDAA,ODAAvG,UDAG,EDAA,ADAH;ADAI,QDAAuG,MDAA,qBDAO;ADAE,QDAAA,MDAA,gBDAAD,SDAI;ADAC,QDAAC,MDAA,oBDAM;ADAE,QDAAA,MDAA,gBDAAF,UDAK,EDAA;ADA/B,QDAAtG,WDAA,CDAAyG,MDAA,GDAAD,MDAA,kBDAA;ADAV,QDAAxG,WDA2C,ADA1C,CDAAmC,WDAM,EDAG,CDAAsE,MDAiC;ADC9C,YDAIP,eDAU,CDAA,ADAV,IDAiB,EDAA,ADAjB,EDAqB,ADAD,EDAC,CDAE;ADCU,YDAAlB,MDAA,EDAa,ADAb,KDAa,CDAA,ADAb,ODAa,CDAA,ADAbkB,eDAU,CDAC,EDAC,CDAC,CDAA;ADA/B,YDAAjB,MDAA,EDAwC,ADAxC,aDAwC,CDAA,ADAxCzC,sBDAiB,CDACwC,MDAa,CDAE,CDAApC,WDAM,CDAC,CDAA;ADAtD,YDAA5C,WDAsD,ADArD,CDAA0G,eDAU,EDAG,CDAAzB,MDAwC,CDC3C;ADAN,eDAM,ADAL,CDAA7C,MDAC,EDAG,EDAC,CDAA;ADAd,wBDAkD,EDAA;ADA9B,gBDAA8C,MDAA,EDAiB,ADAjB,CDAAgB,eDAU,CDAA,ADAV,IDAiB,GDAA;ADArB,oBDAA9D,MDAC,ADAD,GDAqB,ADAjB,CDAA8C,MDAiB,CDAA,ADArB;ADAqB;ADAA;ADCN,gBDAAC,MDAA,EDAa,ADAb,KDAa,CDAA,ADAb,ODAa,CDAA,ADAbe,eDAU,CDAC,CDAA9D,MDAC,CDAC,CDAA;ADA1C,gBDAApC,WDAmD,ADA/C,CDAA2G,SDAI,EDAG,aDAwC,CDAA,ADAxCnE,sBDAiB,CDAC2C,MDAa,CDAE,CDAAvC,WDAM,CDAC;ADCtC,gBDAAwC,MDAA,ODAAnF,UDAG,EDAA,ADAH;ADAM,gBDAAmF,MDAA,gBDAAsB,eDAU;ADAC,gBDAAtB,MDAA,mBDAK;ADAE,gBDAAA,MDAA,gBDAAuB,SDAI,EDAA;ADA5B,gBDAAtB,MDAA,GDAAD,MDAA,kBDAA;ADAb,gBDAAsB,eDAU,ADAV,EDA2C,ADA9B,CDAArB,MDA8B,CDAA;ADFN,gBDAAjD,MDAC,ADAD,EDAS,ADAL,CDAAA,MDAC,ADAD,EDAK,ADAD,EDAC;ADAA;ADIvC,YDAAkD,MDAA,ODAArF,UDAG,EDAA,ADAH;ADAM,YDAAqF,MDAA,gBDAAnD,WDAM;ADAC,YDAAmD,MDAA,qBDAO;ADAE,YDAAA,MDAA,gBDAAoB,eDAU,EDAA;ADAhC,YDAAnB,MDAA,GDAAD,MDAA,kBDAA;ADAT,YDAAnD,WDAM,ADAN,EDA2C,ADAlC,CDAAoD,MDAkC;ADAA;ADE7C,YDAIa,eDAU,CDAA,ADAV,IDAiB,EDAA,ADAjB,EDAqB,ADAD,EDAC,CDAE,EDCY;ADArC,YDAApG,WDAqC,ADAjC,CDAA4G,aDAQ,EDAG,aDAsB,CDAA,ADAtBlD,eDAU,CDAC0C,eDAU,CDAC;ADC5B,YDAAZ,MDAA,ODAAvF,UDAG,EDAA,ADAH;ADAM,YDAAuF,MDAA,gBDAArD,WDAM;ADAC,YDAAqD,MDAA,wBDAU;ADAE,YDAAA,MDAA,gBDAAoB,aDAQ,EDAA;ADAjC,YDAAnB,MDAA,GDAAD,MDAA,kBDAA;ADAT,YDAArD,WDAM,ADAN,EDA4C,ADAnC,CDAAsD,MDAmC;ADAA;ADE9C,YDAIX,eDAU,ADAV,GDAe,ADAD,EDAC,CDAE;ADCV,YDAAY,MDAA,ODAAzF,UDAG,EDAA,ADAH;ADAM,YDAAyF,MDAA,gBDAAvD,WDAM;ADAC,YDAAuD,MDAA,qBDAO;ADAE,YDAAA,MDAA,aDAAZ,eDAU,EDAA;ADAhC,YDAAa,MDAA,GDAAD,MDAA,kBDAA;ADAT,YDAAvD,WDAM,ADAN,EDA2C,ADAlC,CDAAwD,MDAkC;ADAA;ADE7C,YDAIZ,gBDAW,ADAX,EDAe,ADAD,EDAC,CDAE;ADCV,YDAAa,MDAA,ODAA3F,UDAG,EDAA,ADAH;ADAM,YDAA2F,MDAA,gBDAAzD,WDAM;ADAC,YDAAyD,MDAA,sBDAQ;ADAE,YDAAA,MDAA,aDAAb,gBDAW,EDAA;ADAlC,YDAAc,MDAA,GDAAD,MDAA,kBDAA;ADAT,YDAAzD,WDAM,ADAN,EDA6C,ADApC,CDAA0D,MDAoC;ADAA;ADE/C,eDAA1D,WDAM;ADAA,KDCP;AD/bM,iBDON,ADFE,CDAAiB,KDAK,ADLG,CDAAyD,KDAK,CDCF,ADAN,MDAM,ADAZ,CDAAC,SDAY,CDCK,ADAN,ODAM,ADAjB,CDAAC,cDAiB,CDCE,ADAP,QDAO,ADAnB,CDAAC,eDAmB,CDCF,ADAP,QDAO,ADAjB,CDAAC,aDAiB,CDCV;ADCP,kBDAI,CDAA7D,KDAK,CDAC0D,SDAI,CDAE,CDAAC,cDAS,CDAE,CDAAC,eDAU,CDAE,CDAAC,aDAQ,CDAC;ADAA;ADS3C,iBDgBN,ADhB2C,QDAO,ADAxC,CDAAC,iBDAiB,CDAa,ADAN,MDAM,ADAZ,CDAAJ,SDAY,CDAW,EDAA;ADAR,eDAO,ADAP,CDAAnG,WDAA,CDAO;A,Y,M;ADAC,QDAAI,ODgBnD,CDAA,ADhBmD;ADClD,gBDAI+F,SDAI,CDAA,ADAJ,ODAY,GDAE;ADAE,gBDAAnG,WDAY,ADAZ,EDAY,ADAL,MDAK,CDAA;ADAZ,sBDAAI,ODAY;ADAA;ADChC,mBDAAqG,UDAA,EDAc,CDAAN,SDAI,CDAA;A,gB,W;A;A,yC,U,E,W;A;A;A,oB,e,G,U,a,W;ADAb,mBDAK,ADAD,CDAAd,MDAC,EDAA,A,C,e;ADCR,oBDAIA,MDAC,ADAD,GDAY,ADAP,GDAO,CDAA,ADAhB;ADCE,wBDAIA,MDAC,ADAD,GDAY,ADAP,GDAO,CDAA,ADAhB;ADCE,4BDAIA,MDAC,ADAD,EDAW,ADAP,IDAO,CDAE;ADAE,4BDAArF,WDAY,ADAZ,EDAY,ADAL,MDAK,CDAA;ADAZ,kCDAAI,ODAY;ADAA;ADAG,qBDOnC,KDAA,ADRD,KDEWiF,MDAC,ADAD,GDAY,ADAP,GDAO,CDAA,ADFvB;ADGE,4BDAIA,MDAC,ADAD,EDAW,ADAP,GDAO,CDAE;ADAE,4BDAArF,WDAY,ADAZ,EDAY,ADAL,MDAK,CDAA;ADAZ,kCDAAI,ODAY;ADAA;ADAG,qBDKnC,KDAA,ADRD,KDIWiF,MDAC,ADAD,GDAY,ADAP,GDAO,CDAA,ADJvB;ADKE,4BDAIA,MDAC,ADAD,EDAW,ADAP,GDAO,CDAE;ADAE,4BDAArF,WDAY,ADAZ,EDAY,ADAL,MDAK,CDAA;ADAZ,kCDAAI,ODAY;ADAA;ADAG,qBDGnC,KDAA,ADFM;ADCL,wBDAAJ,WDAY,ADAZ,EDAY,ADAL,MDAK,CDAA;ADAZ,8BDAAI,ODAY;ADAA;ADCb,iBDCF;A,gB,M,mB,U,E,W;A,gB,W,G,M;A;ADbuC,YDAAJ,WDe1C,EDAI,ADAJ,KDAI;ADAA;ADCL,cDAA,ADhB2C,CDAAA,WDAA;ADgB3C;ADEM,iBDON,ADP0D,CDAAgC,MDAM,ADAtD,CDAAC,MDAM,CDAkB,ADAN,MDAM,ADAjB,CDAA2E,cDAiB,CDAqB,ADAX,KDAW,ADAX,CDAAnE,KDAW,CDAA,ADAnB,CDAAoE,WDAmB,CDAU;ADChE,YDAI,CDA6B,ADA5B,YDA4B,CDAA,ADA5BN,iBDAiB,CDACK,cDAS,CDAC,CDAA,ADAjC;ADAqC,sBDAO,CDAA,ADAP,MDAO;ADAA,SDCK;ADAjD,QDAAnE,KDAiD,ADA7C,CDAAqE,YDAO,EDAG,IDAI,CDAArE,KDAK,CDAC,IDAI,CDAE,MDAK,CDAE,KDAI,CDAE,MDAK,CDAC,CDCT;ADAxC,YDAwC,ADAxC,CDAAA,KDAwC,CDAA,ADApC,CDAAsE,cDAS,EDAG,cDAwB,ADAxB,EDAwB;ADCxC,YDAsB,CDAA,ADAtB,ODAsB,CDAA,ADAtBA,cDAS,CDAK,CDAAD,YDAO,CDAC;ADCtB,YDAwB,CDAA,ADAxB,UDAwB,CDAA,ADAxBC,cDAS,CDAQ,CDAAF,WDAM,CDAC,CDCgB;ADAlB,YDAkB,ADAlB,CDAApE,KDAkB,CDAA,ADAlB,CDAAuE,MDAkB,EDAA,ADAlB,KDAkB,CDAA,ADAlB,MDAkB,CDAA,ADAlBD,cDAS,CDAS,CDAA;ADAxC,kBDAI,CDAA/E,MDAM,CDAC4E,cDAS,CDAE,CDAAI,MDAkB,CDAC;ADAA;ADgapC,iBD+BN,AD5BE,CDAA3H,WDAW,ADHH,CDAA4H,WDAW,CDCN,ADANjF,MDAM,ADAd,CDAAC,WDAc,CDCa,ADAnB,IDAmB,ADAnB,ODAmB,CDAA,ADAnB,ODAmB,CDAA,ADA3B,CDAAiF,WDA2B,CDCd,EDAA;ADAZ,QDAA7H,WDAW,ADAX,CDAAW,WDAA,CDCmC;ADAhB,cDAgB,ADAhB,CDAAmH,MDAgB,CDCP;ADAb,YDAa,ADAb,CDAA1E,KDAa,CDAA,ADAb,CDAA2E,MDAa;ADIpB,QDAA9H,UDAA,CDAA+H,MDAA,CDGuC;ADA9C,YDA8C,ADA9C,ODA8C,CDAA,ADA9C,CDAAC,MDA8C,CDEH;ADAjB,cDAiB,ADAjB,CDAAC,MDAiB;ADG3C,QDAAjI,UDAA,CDAAkI,MDAA;ADAA,QDAAnI,WDAA,CDAAoI,MDAA;ADEA,QDAAnI,UDAA,CDAAoI,MDAA;ADAA,QDAArI,WDAA,CDAAsI,MDAA,CDEkC;ADAhB,WDAgB,ADAhB,CDAAC,MDAgB,CDCM;ADAjB,cDAiB,ADAjB,CDAAC,MDAiB;ADG/B,QDAAvI,UDAA,CDAAwI,MDAA;ADAA,QDAAzI,WDAA,CDAA0I,MDAA;ADEA,QDAAzI,UDAA,CDAA0I,MDAA;ADAA,QDAA3I,WDAA,CDAA4I,MDAA;ADGX,QDAA3I,UDAA,CDAA4I,MDAA,CDAA;ADdW,WDAkB,ADAlB,CDAAC,MDAkB,CDAA;ADDmB,QDAA9I,WDG/C,ADH+C,CDAA+I,MDG/C,CDMyB;ADAb,WDAa,ADAb,CDAAC,MDAa,CDAA;ADAb,WDAa,ADAb,CDAAC,MDAa,CDAA;ADrBb,QDAAlI,OD4Bd,CDAA,AD5Bc;ADCO,YDAA+G,MDAA,EDAgB,ADAhB,CDAAlF,WDAM,CDAU,eDAA;ADApC,YDAA5C,WDAqC,ADAjC,CDAAsG,UDAK,EDAG,aDAyB,CDAA,ADAzBjF,YDAO,CDACyG,MDAgB,CDAC;ADCrB,YDAAC,MDAA,EDAa,ADAb,CDAAnF,WDAM,CDAO;ADAQ,sBDAAQ,KDAA,EDAArC,QDAA,EDAG,CDAA+E,MDAC,ADAJ,GDCnC,EDAiB;ADAN,sBDAM,ADAN,CDAAoD,MDAM,EDAA,ADAN,CDAApD,MDAC,CDAK,UDAA;ADAjB,uBDAA+B,WDAM,CDAA,ADAN,WDAkB,CDAA,ADAPqB,MDAM,CDAC;ADAA,aDAA,ADDiB,CDAA;ADArC,gBDEC,ADFD,CDAA9F,KDEC,CDAA,ADFG,CDAA+F,cDAS,EDAG,KDEf,CDAA,ADFe,aDEf,CDAA,ADFepB,MDAa,CDAQ,CDAAhH,QDEpC;ADCD,gBDAIoI,cDAS,CDAA,ADAT,IDAgB,EDAA,ADAhB,GDAqB,ADAD,EDAC,CDAE;ADClB,gBDAAnB,MDAA,ODAA/H,UDAG,EDAA,ADAH;ADAA,gBDAAU,WDAA,GDAAqH,MDAA,kBDAA;ADAP,sBDAAjH,ODAY;ADAA;ADGE,qBDAAqC,KDAA,UDAArC,QDAA,EDAG,CDAA+E,MDAC,ADAJ,GDAwB,CDAAA,MDAC,CDAK,SDAA,ADA9B,CDAA;ADAd,YDAAmC,MDAA,EDA8C,ADA9C,KDA8C,CDAA,ADA9C,eDA8C,CDAA,ADA9CkB,cDAS,CDAK,CDAApI,QDAgC,EDAA;ADDhD,YDAAf,WDEC,ADFG,CDAAoJ,aDAQ,EDAG,aDEd,CDAA,ADFc5H,kBDAa,CDC1ByG,MDA8C,CDC/C;ADC2B,YDAAC,MDAA,EDAiB,ADAjB,KDAY,CDAA,ADAZ,ODAY,CDAA,ADAZiB,cDAS,CDAC,EDAC,CDAC,CDAK,UDAA;ADA7C,kBDAkD,ADA9C,CDAAE,aDAQ,EDAG,CDAAxB,WDAM,CDAA,ADAN,YDAmC,CDAA,ADAtBK,MDAiB,CDAE,GDAE,CDAC;ADCvC,gBDAI,IDAY,CDAA,ADAZ,ODAY,CDAA,ADAZiB,cDAS,CDAC,EDAC,CDAC,CDAU,eDAA,ADAtB,MDA+B,CDAA,ADAL,KDAK,EDAE,EDCV;ADApC,mBDAoC,ADAhC,CDAAG,ODAE,CDA8B;ADA3B,oBDAAC,ODAA;ADAA;ADAA,oBDAAT,MDAA,EDAkB,ADAlB,KDAkB,CDAA,ADAlB,WDAkB,CDAA,ADAlBO,aDAQ,CDAU,CDAA;ADAlB,oBDAAE,ODAA,EDAkB,ADAlB,CDAAT,MDAkB;ADAA,iBDAQ,QDAC,ADAD,gBDAC,ADAD,UDAC,CDAA,ADAD;ADAA,oBDAAS,ODAA,EDAC,ADAD,EDAC;ADAA;ADAA,gBDAAD,ODAA,GDAAC,ODAA;ADCpC,gBDAApB,MDAA,ODAAlI,UDAG,EDAA,ADAH;ADAM,gBDAAkI,MDAA,aDAAmB,ODAE,EDAA;ADAR,gBDAAlB,MDAA,GDAAD,MDAA,kBDAA;ADF8C,gBDAAY,MDAA,EDG/C,ADH+C,CDAAX,MDG/C;ADAA,kBDAM;ADCL,gBDAAC,MDAA,ODAApI,UDAG,EDAA,ADAH;ADAM,gBDAAoI,MDAA,cDAAgB,aDAQ,EDAA;ADAd,gBDAAf,MDAA,GDAAD,MDAA;ADAA,gBDAAU,MDAA,EDAgB,ADAhB,CDAAT,MDAgB;ADAA,aDCjB;ADLE,YDAAtI,WDKF,ADLG,CDAAwJ,SDAI,EDAG,CDAAT,MDKV,CDCa;ADAN,eDAM,ADAL,CDAA3G,MDAC,EDAG,EDAC,CDAA;ADAd,wBDAiD,EDAA;ADA7B,gBDAAmG,MDAA,EDAgB,ADAhB,CDAAY,cDAS,CDAA,ADAT,IDAgB,GDAA;ADApB,oBDAA/G,MDAC,ADAD,GDAoB,ADAhB,CDAAmG,MDAgB,CDAA,ADApB;ADAoB;ADAA;ADCX,gBDAAC,MDAA,EDAiB,ADAjB,KDAY,CDAA,ADAZ,ODAY,CDAA,ADAZW,cDAS,CDAC,CDAA/G,MDAC,CDAC,CDAK,UDAA;ADAxC,sBDA6C,ADAzC,CDAAqH,QDAG,EDAG,CDAA5B,WDAM,CDAA,ADAN,YDAmC,CDAA,ADAtBW,MDAiB,CDAE,GDAE,CDAC;ADC7C,oBDAI,IDAY,CDAA,ADAZ,ODAY,CDAA,ADAZW,cDAS,CDAC,CDAA/G,MDAC,CDAC,CDAU,eDAA,ADAtB,MDA+B,CDAA,ADAL,KDAK,EDAE;ADC1B;ADAA,wBDAA4G,MDAA,EDAa,ADAb,KDAa,CDAA,ADAb,WDAa,CDAA,ADAbS,QDAG,CDAU,CDAA;ADAb,wBDAAR,MDAA,EDAa,ADAb,CDAAD,MDAa;ADAA,qBDAQ,QDAC,ADAD,gBDAC,ADAD,UDAC,CDAA,ADAD;ADAA,wBDAAC,MDAA,EDAC,ADAD,EDAC;ADAA,qBDAA;ADA/B,uBDA+B,ADA3B,CDAAK,ODAE,EDAG,CDAAL,MDAsB;ADCxB,oBDAAR,MDAA,ODAAxI,UDAG,EDAA,ADAH;ADAM,oBDAAwI,MDAA,gBDAAe,SDAI;ADAC,oBDAAf,MDAA,gBDAE;ADAE,oBDAAA,MDAA,aDAAa,ODAE,EDAA;ADAjB,oBDAAZ,MDAA,GDAAD,MDAA,kBDAA;ADAP,oBDAAe,SDAI,ADAJ,EDA0B,ADAnB,CDAAd,MDAmB;ADAA,iBDC3B,KDAM;ADCE,oBDAAC,MDAA,ODAA1I,UDAG,EDAA,ADAH;ADAM,oBDAA0I,MDAA,gBDAAa,SDAI;ADAC,oBDAAb,MDAA,gBDAE;ADAE,oBDAAA,MDAA,cDAAc,QDAG,EDAA;ADAlB,oBDAAb,MDAA,GDAAD,MDAA,kBDAA;ADAP,oBDAAa,SDAI,ADAJ,EDA2B,ADApB,CDAAZ,MDAoB;ADAA,iBDC5B;ADPmC,gBDAAxG,MDAC,ADAD,EDAS,ADAL,CDAAA,MDAC,ADAD,EDAK,ADAD,EDAC;ADAA;ADS/C,YDAAyG,MDAA,ODAA5I,UDAG,EDAA,ADAH;ADAI,YDAA4I,MDAA,0BDAY;ADAE,YDAAA,MDAA,gBDAAvC,UDAK;ADAC,YDAAuC,MDAA,gBDAE;ADAE,YDAAA,MDAA,gBDAAO,aDAQ;ADAC,YDAAP,MDAA,wBDAU;ADAE,YDAAA,MDAA,gBDAAW,SDAI;ADAC,YDAAX,MDAA,eDAC,EDAA;ADAvD,YDAAlI,WDAA,GDAAkI,MDAA;ADAA;ADCD,cDAA,AD5BE,CDAAlI,WDAA;AD4BF;ADoXM,iBDiFN,ADjFkB,KDAI,ADAZ,CDAA+I,IDAI,EDAS;ADCtB,QDAAtJ,WDAO,CDAC,GDAG,CDAC,uBDAuB,CDAC,CDMnC;ADJD,YDIC,ADJD,CDAAgD,KDIC,CDAA,ADJG,CDAAuG,eDAU,EDAG,KDIhB,CDAA,ADJgB,EDIhB,CDAA,ADHC,YDAqC,CDAA,ADArC9C,KDAK,CDAC,MDAM,CDAE,SDAQ,CDAE,MDAK,CDAE,MDAK,CDAC,CDCrC,aDAiC,CDAA,ADAjCA,KDAK,CDAC,KDAK,CDAE,MDAK,CDAE,MDAK,CDAE,MDAK,CDAC,CDCjC,aDAqC,CDAA,ADArCA,KDAK,CDAC,ODAO,CDAE,SDAQ,CDAE,MDAK,CDAE,KDAI,CDAC,CDCtC,CDC2C;ADA5C,QDAAlE,MDA4C,ADAxC,CDAAiH,eDAU,EDAG,aDA2B,CDAA,ADA3BhH,MDAM,CDAC,ODAO,CDAE,CDAA+G,eDAU,CDAC,CDEX;ADArB,cDAqB,ADArB,CDAAE,MDAqB,EDAA,ADArB,CDAAD,eDAU,CDAC,QDAQ,EDAE,CDAA;ADAjC,QDAAxJ,WDAO,CDAC,GDAG,CDACyJ,MDAqB,CDAC;ADClC,QDAAzJ,WDAO,CDAC,GDAG,CDAC,EDAE,CDAC,CDEgB;ADA/B,QDAA0J,aDA+B,ADA3B,CDAAC,UDAK,EDAG,IDAI,CDAAD,aDAa,EDAE,CDM5B;ADJH,QDAAE,MDIG,ADJC,CDAAC,SDAI,EDAG,CDAAF,UDAK,CDAC,MDAM,CDAC,ODAO,CDAE,KDI/B,CDAA,ADJ+B,cDI/B,CDAA,ADJuD,IDIxD,CDAA,ADJwD,EDIxD,CDAA,ADHC,wBDAyB,ADAzB,EDAyB,CDAA,ADAhB,MDAM,CDAE,QDAO,CDAC,CDCzB,yBDAqB,ADArB,EDAqB,CDAA,ADAZ,KDAK,CDAE,KDAI,CDAC,CDCrB,yBDAsC,ADAtC,EDAsC,CDAA,ADA7B,ODAO,CDAE,oBDAmB,CDAC,CDCvC,CDAC,CDAC,CDMA;ADJH,QDAAC,MDIG,ADJC,CDAAE,SDAI,EDAG,CDAAH,UDAK,CDAC,MDAM,CDAC,ODAO,CDAE,KDI/B,CDAA,ADJ+B,cDI/B,CDAA,ADJuD,IDIxD,CDAA,ADJwD,EDIxD,CDAA,ADHC,wBDAuB,ADAvB,EDAuB,CDAA,ADAd,MDAM,CDAE,MDAK,CDAC,CDCvB,yBDAqB,ADArB,EDAqB,CDAA,ADAZ,KDAK,CDAE,KDAI,CDAC,CDCrB,yBDAoC,ADApC,EDAoC,CDAA,ADA3B,ODAO,CDAE,kBDAiB,CDAC,CDCrC,CDAC,CDAC,CDMA;ADJH,QDAAC,MDIG,ADJC,CDAAG,SDAI,EDAG,CDAAJ,UDAK,CDAC,MDAM,CDAC,ODAO,CDAE,KDI/B,CDAA,ADJ+B,cDI/B,CDAA,ADJuD,IDIxD,CDAA,ADJwD,EDIxD,CDAA,ADHC,wBDA2B,ADA3B,EDA2B,CDAA,ADAlB,MDAM,CDAE,UDAS,CDAC,CDC3B,yBDAqB,ADArB,EDAqB,CDAA,ADAZ,KDAK,CDAE,KDAI,CDAC,CDCrB,yBDAwC,ADAxC,EDAwC,CDAA,ADA/B,ODAO,CDAE,sBDAqB,CDAC,CDCzC,CDAC,CDAC;ADEH,QDAA3J,WDAO,CDAC,GDAG,CDAC,mBDAmB,CDAC,CDCA;ADAf,cDAe,ADAf,CDAAgK,MDAe,EDAA,ADAf,CDAAH,SDAI,CDAC,QDAQ,EDAE,CDAA;ADAhC,QDAA7J,WDAO,CDAC,GDAG,CDAM,ADAJ,IDAI,EDAe,ADAf,CDAAgK,MDAiB,CDAC,CDCH;ADAf,cDAe,ADAf,CDAAC,MDAe,EDAA,ADAf,CDAAH,SDAI,CDAC,QDAQ,EDAE,CDAA;ADAhC,QDAA9J,WDAO,CDAC,GDAG,CDAM,ADAJ,IDAI,EDAe,ADAf,CDAAiK,MDAiB,CDAC,CDCH;ADAf,cDAe,ADAf,CDAAC,MDAe,EDAA,ADAf,CDAAH,SDAI,CDAC,QDAQ,EDAE,CDAA;ADAhC,QDAA/J,WDAO,CDAC,GDAG,CDAM,ADAJ,IDAI,EDAe,ADAf,CDAAkK,MDAiB,CDAC;ADCnC,QDAAlK,WDAO,CDAC,GDAG,CDAC,EDAE,CDAC;ADEf,QDAAA,WDAO,CDAC,GDAG,CDAC,6BDA6B,CDAC;ADE1C,QDAAA,WDAO,CDAC,GDAG,CDAC,YDAY,CDAC,CDCwB;ADAjD,YDAiD,ADAjD,CDAA4J,MDAiD,CDAA,ADA7C,CDAAO,aDAQ,EDAG,IDAI,CDAAC,KDAK,CDACZ,eDAU,CDAE,CDAAG,UDAK,CDAC,CDAC,GDAG,EDAE;ADCzB,iBDAAC,MDAA,EDAAjJ,QDAA,EDAA,ADAf,CDAA0J,MDAe,KDCO;ADAZ,kBDAY,ADAZ,CDAAC,MDAY,EDAA,ADAZ,CDAAD,MDAC,CDAC,QDAQ,EDAE,CDAA;ADA7B,YDAArK,WDAO,CDAC,GDAG,CDAM,ADAJ,IDAI,EDAY,ADAZ,CDAAsK,MDAc,CDAC;ADAA,SDCjC,ADFuB,CDAA;ADAV,QDAAH,aDAQ,QDAE,CDAAxJ,QDEvB,CDAA,ADFD;ADGA,QDAAX,WDAO,CDAC,GDAG,CDAC,EDAE,CDAC;ADEf,QDAAA,WDAO,CDAC,GDAG,CDAC,qBDAqB,CDAC,CDG1B;ADFR,YDEQ,ADFR,CDAA4J,MDEQ,CDAA,ADFJ,CDAAW,WDAM,EDAG,IDAI,CDAAH,KDAK,CDACZ,eDAU,CDAE,CDAAG,UDAK,CDAC,CDCtC,KDAK,CDAC,KDAK,CDAE,KDAI,CDAE,KDAI,CDAC,CDCxB,GDAG,EDAE;ADCc,iBDAAC,MDAA,EDAAjJ,QDAA,EDAA,ADAb,CDAA0J,MDAa,KDCS;ADAZ,kBDAY,ADAZ,CDAAG,MDAY,EDAA,ADAZ,CDAAH,MDAC,CDAC,QDAQ,EDAE,CDAA;ADA7B,YDAArK,WDAO,CDAC,GDAG,CDAM,ADAJ,IDAI,EDAY,ADAZ,CDAAwK,MDAc,CDAC;ADAA,SDCjC,ADFqB,CDAA;ADAR,QDAAD,WDAM,QDAE,CDAA5J,QDErB,CDAA,ADFD;ADGA,QDAAX,WDAO,CDAC,GDAG,CDAC,EDAE,CDAC;ADEf,QDAAA,WDAO,CDAC,GDAG,CDAC,+CDA+C,CDAC,CDEvB;ADArC,QDAAoK,KDAqC,ADAjC,CDAAK,ODAE,EDAG,IDAI,CDAAL,KDAK,CDACZ,eDAU,CDAE,CDAAG,UDAK,CDAC,CDCW;ADArB,cDAqB,ADArB,CDAAe,MDAqB,EDAA,ADArB,CDAAD,ODAE,CDAC,KDAK,EDAE,CDAC,QDAQ,EDAE,CDAA;ADAhD,QDAAzK,WDAO,CDAC,GDAG,CDAgB,ADAd,cDAc,EDAqB,ADArB,CDAA0K,MDAuB,CDAC,CDMvC;ADJZ,QDAAN,KDIY,ADJR,CDAAO,ODAE,EDAG,IDAI,CDAAP,KDAK,CDACZ,eDAU,CDAE,CDAAG,UDAK,CDAC,CDClC,MDAM,CDAC,IDAe,CDAA,ADAf,EDAe,CDAA,ADAd,MDAM,CDAE,MDAK,CDAC,CDAC,CDCvB,KDAK,CDAC,KDAK,CDAE,KDAI,CDAE,KDAI,CDAC,CDCxB,ODAO,CDAC,KDAK,CDAE,ODAM,CDAC,CDCtB,KDAK,CDAC,EDAE,CDAC,CDCoC;ADArB,cDAqB,ADArB,CDAAiB,MDAqB,EDAA,ADArB,CDAAD,ODAE,CDAC,KDAK,EDAE,CDAC,QDAQ,EDAE,CDAA;ADAhD,QDAA3K,WDAO,CDAC,GDAG,CDAgB,ADAd,cDAc,EDAqB,ADArB,CDAA4K,MDAuB,CDAC,CDER;ADA3C,cDA2C,ADAvC,CDAAC,UDAK,EDAG,gCDA+B,CDEf;ADD5B,QDAAT,KDC4B,ADDxB,CDAAU,ODAE,EDAG,IDAI,CDAAV,KDAK,CDACZ,eDAU,CDAE,CDAAG,UDAK,CDAC,CDClC,KDAK,CDAC,MDAM,CDAE,IDAG,CDAE,gCDAK,CDAC,CDCoB;ADArB,cDAqB,ADArB,CDAAoB,MDAqB,EDAA,ADArB,CDAAD,ODAE,CDAC,KDAK,EDAE,CDAC,QDAQ,EDAE,CDAA;ADAhD,QDAA9K,WDAO,CDAC,GDAG,CDAgB,ADAd,cDAc,EDAqB,ADArB,CDAA+K,MDAuB,CDAC,CDKjD;ADHF,WDGE,ADHF,ODGE,CDAA,ADHF,ODGE,CDAA,ADHE,CDAAC,eDAU,EDAG,KDGf,CDAA,ADHe,cDGf,CDAA,ADHuC,IDGxC,CDAA,ADHwC,EDGxC,CDAA,ADFC,wBDA4B,ADA5B,EDA4B,CDAA,ADAnB,MDAM,CDAE,WDAU,CDAC,CDC5B,yBDAqB,ADArB,EDAqB,CDAA,ADAZ,KDAK,CDAE,KDAI,CDAC,CDCtB,CDAC,CDCuE;ADA9C,cDA8C,ADA9C,CDAAC,MDA8C,EDAA,ADA9C,aDAmC,CDAA,ADAnCzD,WDAW,CDACgC,eDAU,CDAE,CDAAwB,eDAU,CDAC,CDAC,QDAQ,EDAE,CDAA;ADAzE,QDAAhL,WDAO,CDAC,GDAG,CDAgB,ADAd,cDAc,EDA8C,ADA9C,CDAAiL,MDAgD,CDAC;ADE5E,QDAAjL,WDAO,CDAC,GDAG,CDAC,yBDAyB,CDAC;ADAA,KDCvC;AD36BM,iBDYN,ADZsC,CDAAkL,SDAS,ADArC,CDAAC,YDAY,CDAa,ADAN,MDAM,ADAZ,CDAAC,SDAY,CDAa,EDAA;ADAV,QDAAF,SDAS,ADAT,CDAA3K,WDAA;ADAU,QDAAI,ODYhD,CDAA,ADZgD;ADC/C,yBDAAqG,UDAA,EDAe,CDAA/G,mBDAc,CDAA;A,gB,O,G,U;A,gB,O;A,mB,O,G,O;A,uB,Q,gB,U,E,O;A,gB,O,G,O;ADAxB,sBDAM,ADAF,CDAAsL,ODAE,EDAA,A,C,Q;ADCT,oBDAIA,ODAE,CDAA,ADAF,MDAU,CDAA,ADAJH,SDAI,EDAE;ADCP,oBDAA7K,WDAA,EDAwB,ADAxB,IDAI,CDAA2K,SDAS,CDAC,SDAS,CDAC,CDAA;ADA/B,0BDAAvK,ODA+B;ADAA;ADChC,aDAA;ADEH,yBDAAqG,UDAA,EDAe,CDAA9G,gBDAW,CDAA;A,gB,O,G,U;A,gB,O;A,mB,O,G,O;A,uB,Q,gB,U,E,O;A,gB,O,G,O;ADArB,sBDAM,ADAF,CDAAsL,ODAE,EDAA,A,C,Q;ADCT,oBDAIA,ODAE,CDAA,ADAF,MDAU,CDAA,ADAJJ,SDAI,EDAE;ADCP,oBDAA7K,WDAA,EDAqB,ADArB,IDAI,CDAA2K,SDAS,CDAC,MDAM,CDAC,CDAA;ADA5B,0BDAAvK,ODA4B;ADAA;ADC7B,aDAA;ADEH,YDAAJ,WDAA,EDA2B,ADA3B,IDAI,CDAA2K,SDAS,CDAC,YDAY,CDAC;ADAA;ADC5B,cDAA,ADZsC,CDAA3K,WDAA;ADYtC;ADQM,iBDON,ADPuC,CDAAT,QDAQ,ADArC,CDAA2L,aDAa,CDAa,ADAN,MDAM,ADAZ,CDAAL,SDAY,CDAY,EDAA;ADAT,QDAAtL,QDAQ,ADAR,CDAAS,WDAA;ADE7B,QDAAR,eDAA,CDAA2L,MDAA,CDAA;ADFsC,QDAA/K,ODOhD,CDAA,ADPgD;ADC/C,gBDAIyK,SDAI,CDAA,ADAJ,MDAU,CDAA,ADAF,EDAE,EDAE;ADCP,gBDAAM,MDAA,ODAA3L,eDAI,EDAA,ADAJ;ADAA,gBDAAQ,WDAA,GDAAmL,MDAA,kBDAA;ADAP,sBDAA/K,ODAa;ADAA,aDEmB;ADAlC,YDAAuK,SDAkC,ADA9B,CDAAS,cDAS,EDAG,aDAkB,CDAA,ADAlBR,YDAY,CDACC,SDAI,CDAC,CDCI;ADAtC,YDAAQ,KDAsC,ADAlC,CDAAC,UDAK,EDAG,IDAI,CDAAD,KDAK,CDACD,cDAS,CDAE,CDAAP,SDAI,CDAC;ADCtC,YDAA7K,WDAA,EDAc,ADAd,CDAAsL,UDAK,CDAC,MDAM,EDAE;ADAA;ADCf,cDAA,ADPuC,CDAAtL,WDAA;ADOvC;ADEM,iBDWN,ADXuC,CDAAT,QDAQ,ADArC,CDAAgM,aDAa,CDAa,ADAN,MDAM,ADAZ,CDAAC,SDAY,CDAY,EDAA;ADAT,QDAAjM,QDAQ,ADAR,CDAAS,WDAA;ADG7B,QDAAR,eDAA,CDAAiM,MDAA,CDE2B;ADAvB,QDAAlM,QDAuB,ADAvB,CDAAmM,MDAuB,CDCJ;ADAZ,WDAY,ADAZ,CDAAC,MDAY;ADErB,QDAAnM,eDAA,CDAAoM,MDAA;ADAA,QDAArM,QDAA,CDAAsM,MDAA,CDAA;ADRoC,QDAAzL,ODWhD,CDAA,ADXgD,EDCpB;ADA3B,gBDA2B,ADA3B,ODA2B,CDAA,ADAvB,CDAA0L,UDAK,EDAG,KDAe,CDAA,ADAf,WDAe,CDAA,ADAfN,SDAI,CDAO,IDAG,CDAC;ADC3B,gBDAIM,UDAK,CDAA,ADAL,IDAY,EDAA,ADAZ,GDAiB,ADAD,EDAC,CDAE;ADCd,gBDAAL,MDAA,ODAAjM,eDAI,EDAA,ADAJ;ADAA,gBDAAQ,WDAA,GDAAyL,MDAA,kBDAA;ADAP,sBDAArL,ODAa;ADAA;ADEF,YDAAsL,MDAA,EDAuB,ADAvB,aDAuB,CDAA,ADAvBR,aDAa,CDAC,IDAQ,CDAA,ADAR,ODAQ,CDAA,ADARY,UDAK,CDAC,EDAC,CDAC,CDAC,CDAA;ADAjC,YDAAvM,QDAiC,ADAhC,CDAAiC,WDAM,EDAG,CDAAkK,MDAuB,CDCtB;ADAN,eDAM,ADAL,CDAAjK,MDAC,EDAG,EDAC,CDAA;ADAd,wBDA6C,EDAA;ADAzB,gBDAAkK,MDAA,EDAY,ADAZ,CDAAG,UDAK,CDAA,ADAL,IDAY,GDAA;ADAhB,oBDAArK,MDAC,ADAD,GDAgB,ADAZ,CDAAkK,MDAY,CDAA,ADAhB;ADAgB;ADAA,iBDCI;ADAlC,gBDAApM,QDAkC,ADA9B,CDAAsL,SDAI,EDAG,aDAuB,CDAA,ADAvBK,aDAa,CDAC,IDAQ,CDAA,ADAR,ODAQ,CDAA,ADARY,UDAK,CDAC,CDAArK,MDAC,CDAC,CDAC;ADCzB,gBDAAmK,MDAA,ODAApM,eDAI,EDAA,ADAJ;ADAO,gBDAAoM,MDAA,gBDAApK,WDAM;ADAC,gBDAAoK,MDAA,eDAC;ADAE,gBDAAA,MDAA,gBDAAf,SDAI,EDAA;ADArB,gBDAAgB,MDAA,GDAAD,MDAA,kBDAA;ADAT,gBDAApK,WDAM,ADAN,EDAgC,ADAvB,CDAAqK,MDAuB,CDAA;ADFA,gBDAApK,MDAC,ADAD,EDAS,ADAL,CDAAA,MDAC,ADAD,EDAK,ADAD,EDAC;ADAA,aDI3C;ADVsC,YDAAzB,WDUtC,EDAM,ADAN,CDAAwB,WDAM;ADAA;ADCP,cDAA,ADXuC,CDAAxB,WDAA;ADWvC;ADEM,iBDWN,ADX2C,CDAAT,QDAQ,ADAzC,CDAAwM,eDAe,CDAe,ADAN,MDAM,ADAd,CDAAC,WDAc,CDAY,EDAA;ADAT,QDAAzM,QDAQ,ADAR,CDAAS,WDAA;ADGjC,QDAAR,eDAA,CDAAyM,MDAA,CDE2B;ADAvB,QDAA1M,QDAuB,ADAvB,CDAA2M,MDAuB,CDCJ;ADAZ,WDAY,ADAZ,CDAAC,MDAY;ADErB,QDAA3M,eDAA,CDAA4M,MDAA;ADAA,QDAA7M,QDAA,CDAA8M,MDAA,CDAA;ADRwC,QDAAjM,ODWpD,CDAA,ADXoD,EDCrB;ADA9B,gBDA8B,ADA9B,ODA8B,CDAA,ADA1B,CDAAkM,UDAK,EDAG,KDAkB,CDAA,ADAlB,WDAkB,CDAA,ADAlBN,WDAM,CDAO,KDAI,CDAC;ADC9B,gBDAIM,UDAK,CDAA,ADAL,IDAY,EDAA,ADAZ,GDAiB,ADAD,EDAC,CDAE;ADCd,gBDAAL,MDAA,ODAAzM,eDAI,EDAA,ADAJ;ADAA,gBDAAQ,WDAA,GDAAiM,MDAA,kBDAA;ADAP,sBDAA7L,ODAa;ADAA;ADEF,YDAA8L,MDAA,EDAuB,ADAvB,aDAuB,CDAA,ADAvBX,aDAa,CDAC,IDAQ,CDAA,ADAR,ODAQ,CDAA,ADARe,UDAK,CDAC,EDAC,CDAC,CDAC,CDAA;ADAjC,YDAA/M,QDAiC,ADAhC,CDAAiC,WDAM,EDAG,CDAA0K,MDAuB,CDCtB;ADAN,eDAM,ADAL,CDAAzK,MDAC,EDAG,EDAC,CDAA;ADAd,wBDA6C,EDAA;ADAzB,gBDAA0K,MDAA,EDAY,ADAZ,CDAAG,UDAK,CDAA,ADAL,IDAY,GDAA;ADAhB,oBDAA7K,MDAC,ADAD,GDAgB,ADAZ,CDAA0K,MDAY,CDAA,ADAhB;ADAgB;ADAA,iBDCI;ADAlC,gBDAA5M,QDAkC,ADA9B,CDAAiM,SDAI,EDAG,aDAuB,CDAA,ADAvBD,aDAa,CDAC,IDAQ,CDAA,ADAR,ODAQ,CDAA,ADARe,UDAK,CDAC,CDAA7K,MDAC,CDAC,CDAC;ADCzB,gBDAA2K,MDAA,ODAA5M,eDAI,EDAA,ADAJ;ADAO,gBDAA4M,MDAA,gBDAA5K,WDAM;ADAC,gBDAA4K,MDAA,iBDAE;ADAE,gBDAAA,MDAA,gBDAAZ,SDAI,EDAA;ADAtB,gBDAAa,MDAA,GDAAD,MDAA,kBDAA;ADAT,gBDAA5K,WDAM,ADAN,EDAiC,ADAxB,CDAA6K,MDAwB,CDAA;ADFD,gBDAA5K,MDAC,ADAD,EDAS,ADAL,CDAAA,MDAC,ADAD,EDAK,ADAD,EDAC;ADAA,aDI3C;ADV0C,YDAAzB,WDU1C,EDAM,ADAN,CDAAwB,WDAM;ADAA;ADCP,cDAA,ADX2C,CDAAxB,WDAA;ADW3C;ADEM,iBDGN,ADH0C,CDAAT,QDAQ,ADAxC,CDAAgN,cDAc,CDAe,ADAN,MDAM,ADAd,CDAAP,WDAc,CDAY,EDCT;ADAzC,QDAAzM,QDAyC,ADArC,CDAAiN,gBDAW,EDAG,aDAuB,CDAA,ADAvBT,eDAe,CDACC,WDAM,CDAC;ADCzC,QDAAxM,eDAA,CDAAiN,MDAA,ODAAjN,eDAI,EDAA,ADAJ;ADAK,QDAAiN,MDAA,6CDA+B;ADAE,QDAAA,MDAA,gBDAAD,gBDAW;ADAC,QDAAC,MDAA,2BDAa,EDAA;ADA/D,eDAAA,MDAA;ADAA,KDCD;A;ADtHY,QDAAhN,WDAA,+CDAA;AD0Cb,QDAAC,mBDKC,ADLD,EDKC,ADLkC,KDKlC,CDAA,ADLkC,EDKlC,CDAA,ADJC,IDAI,CDAE,ODAM,CDAE,MDAK,CDAE,QDAO,CDAE,KDAI,CDAE,ODAM,CDAE,QDAO,CDAE,WDAU,CDAE,SDAQ,CDCzE,MDAK,CDAE,MDAK,CDAE,QDAO,CDAE,SDAQ,CDAE,SDAQ,CDAE,SDAQ,CDAE,UDAS,CDAE,YDAW,CDC3E,SDAQ,CDAE,MDAK,CDAE,ODAM,CDAE,MDAK,CDAE,MDAK,CDAE,SDAQ,CDAE,UDAS,CDAE,aDAY,CDCxE,ODAM,CDAE,QDAO,CDAE,ODAM,CDAE,SDAQ,CDAE,SDAQ,CDAE,KDAI,CDClD;ADED,QDAAC,gBDKC,ADLD,EDKC,ADL+B,KDK/B,CDAA,ADL+B,EDK/B,CDAA,ADJC,QDAQ,CDAE,MDAK,CDAE,UDAS,CDAE,ODAM,CDAE,MDAK,CDAE,SDAQ,CDAE,ODAM,CDC3D,QDAO,CDAE,SDAQ,CDAE,ODAM,CDAE,QDAO,CDAE,ODAM,CDAE,ODAM,CDAE,ODAM,CDC1D,SDAQ,CDAE,SDAQ,CDAE,QDAO,CDAE,QDAO,CDAE,gBDAe,CDCrD,cDAa,CDAE,aDAY,CDAE,cDAa,CDAE,cDAa,CDC1D;ADAA,KDAA;A" }