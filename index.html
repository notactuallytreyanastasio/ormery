<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ORMery - A Multi-Language ORM from Temper</title>
  <meta name="description" content="ORMery is a query builder and ORM written in Temper that compiles to 6 languages. See how the same ORM looks in JavaScript, Python, C#, Rust, Java, and Lua.">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color: #1a1a1a;
      background: #fff;
      line-height: 1.7;
      font-size: 16px;
    }
    .container {
      max-width: 720px;
      margin: 0 auto;
      padding: 3rem 1.5rem 4rem;
    }
    h1 {
      font-size: 2.4rem;
      font-weight: 700;
      margin-bottom: 0.25rem;
      letter-spacing: -0.02em;
    }
    .subtitle {
      color: #666;
      font-size: 1.1rem;
      margin-bottom: 2.5rem;
    }
    h2 {
      font-size: 1.5rem;
      font-weight: 600;
      margin-top: 3rem;
      margin-bottom: 0.75rem;
      padding-bottom: 0.3rem;
      border-bottom: 1px solid #e5e5e5;
    }
    h3 {
      font-size: 1.15rem;
      font-weight: 600;
      margin-top: 2rem;
      margin-bottom: 0.5rem;
    }
    p { margin-bottom: 1rem; }
    a { color: #0066cc; text-decoration: none; }
    a:hover { text-decoration: underline; }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0 1.5rem;
      font-size: 0.9rem;
    }
    th, td {
      text-align: left;
      padding: 0.5rem 0.75rem;
      border: 1px solid #e0e0e0;
    }
    th {
      background: #f7f7f7;
      font-weight: 600;
    }
    tr:nth-child(even) td { background: #fafafa; }
    pre {
      background: #f5f5f5;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 0.75rem 1rem;
      overflow-x: auto;
      margin: 0.75rem 0 1.25rem;
      font-size: 0.85rem;
      line-height: 1.5;
    }
    code {
      font-family: "SF Mono", "Fira Code", "Fira Mono", Menlo, Consolas, monospace;
      font-size: 0.88em;
    }
    p code, li code, td code {
      background: #f0f0f0;
      padding: 0.15em 0.35em;
      border-radius: 3px;
    }
    .pipeline-diagram {
      background: #f9f9f9;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 1.5rem;
      margin: 1rem 0 1.5rem;
      font-family: "SF Mono", "Fira Code", Menlo, Consolas, monospace;
      font-size: 0.82rem;
      line-height: 1.6;
      white-space: pre;
      overflow-x: auto;
    }
    .lang-section {
      margin-top: 1.5rem;
      padding-top: 1rem;
      border-top: 1px solid #eee;
    }
    .lang-section:first-of-type { border-top: none; padding-top: 0; }
    .lang-header {
      display: flex;
      align-items: baseline;
      gap: 0.75rem;
      margin-bottom: 0.25rem;
    }
    .lang-header h3 { margin-top: 0; margin-bottom: 0; }
    .lang-meta { color: #888; font-size: 0.85rem; }
    footer {
      margin-top: 4rem;
      padding-top: 1.5rem;
      border-top: 1px solid #e0e0e0;
      color: #888;
      font-size: 0.85rem;
    }
    footer a { color: #666; }
    .summary-table td:first-child { font-weight: 600; }
  </style>
</head>
<body>
<div class="container">

<h1>ORMery</h1>
<p class="subtitle">A query builder and ORM written in <a href="https://github.com/temperlang/temper">Temper</a> that compiles to six languages.</p>

<p>
  <a href="https://github.com/temperlang/temper">Temper</a> is a programming language that compiles to JavaScript, Python, C#, Rust, Java, and Lua. ORMery is a query builder and ORM written in Temper that produces injection-proof SQL via the <a href="https://github.com/nickreserved/secure-composition">secure-composition</a> library. To demonstrate how ORMery works across all six target languages, we built a retro-styled todo list app in each one, using the idiomatic web framework and database layer for that ecosystem.
</p>
<p>
  This page documents the demo apps, compares their ORM/querying APIs side by side, and explains the CI/CD pipeline that keeps everything in sync.
</p>

<h2>Demo Apps</h2>

<p>Each app is a todo list manager with lists and todos, styled to look like Mac System 6 with Windows 95 windows. Same features, same schema, six different stacks.</p>

<table>
  <thead>
    <tr><th>Language</th><th>Web Framework</th><th>ORM / DB Layer</th><th>Port</th><th>Repo</th></tr>
  </thead>
  <tbody>
    <tr><td>JavaScript</td><td>Express + EJS</td><td>better-sqlite3</td><td>5006</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-js-app">ormery-js-app</a></td></tr>
    <tr><td>Python</td><td>Flask + Jinja2</td><td>SQLAlchemy</td><td>5001</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-py-app">ormery-py-app</a></td></tr>
    <tr><td>C#</td><td>ASP.NET Core Razor</td><td>Entity Framework Core</td><td>5002</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-csharp-app">ormery-csharp-app</a></td></tr>
    <tr><td>Rust</td><td>Axum + Askama</td><td>SQLx</td><td>5003</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-rust-app">ormery-rust-app</a></td></tr>
    <tr><td>Java</td><td>Spring Boot + Thymeleaf</td><td>Spring Data JPA</td><td>5004</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-java-app">ormery-java-app</a></td></tr>
    <tr><td>Lua</td><td>LuaSocket (hand-rolled)</td><td>lsqlite3</td><td>5005</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-lua-app">ormery-lua-app</a></td></tr>
  </tbody>
</table>

<h2>How the ORM Works in Each Language</h2>

<!-- JS -->
<div class="lang-section">
  <div class="lang-header">
    <h3>JavaScript</h3>
    <span class="lang-meta">Express + better-sqlite3 &middot; Port 5006</span>
  </div>
  <p>better-sqlite3 uses synchronous prepared statements. Queries are pre-compiled with <code>db.prepare()</code> and executed with <code>.get()</code>, <code>.all()</code>, or <code>.run()</code>. Transactions are explicit via <code>db.transaction()</code>.</p>

<pre><code>// Prepared statements
const stmts = {
  allLists: db.prepare(`
    SELECT l.*,
      (SELECT COUNT(*) FROM todos WHERE list_id = l.id) AS todo_count,
      (SELECT COUNT(*) FROM todos WHERE list_id = l.id AND completed = 1) AS done_count
    FROM lists l ORDER BY l.created_at DESC
  `),
  getList:    db.prepare('SELECT * FROM lists WHERE id = ?'),
  createList: db.prepare('INSERT INTO lists (name) VALUES (?)'),
  toggleTodo: db.prepare(
    'UPDATE todos SET completed = CASE WHEN completed = 1 THEN 0 ELSE 1 END WHERE id = ?'
  ),
};

// Usage
const lists = stmts.allLists.all();
const list  = stmts.getList.get(id);
stmts.createList.run(name);
stmts.toggleTodo.run(id);</code></pre>
</div>

<!-- Python -->
<div class="lang-section">
  <div class="lang-header">
    <h3>Python</h3>
    <span class="lang-meta">Flask + SQLAlchemy &middot; Port 5001</span>
  </div>
  <p>SQLAlchemy uses declarative model classes. Columns are defined with <code>db.Column()</code>, relationships with <code>db.relationship()</code>. Queries use a fluent, chainable API.</p>

<pre><code>class List(db.Model):
    __tablename__ = "lists"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(120), nullable=False)
    todos = db.relationship("Todo", backref="list", cascade="all, delete-orphan")

# Query
lists = List.query.order_by(List.created_at.asc()).all()
lst = db.get_or_404(List, list_id)
done = Todo.query.filter_by(list_id=lst.id, completed=True).count()

# CRUD
db.session.add(List(name="Work"))
db.session.commit()
todo.completed = not todo.completed
db.session.commit()
db.session.delete(lst)
db.session.commit()</code></pre>
</div>

<!-- C# -->
<div class="lang-section">
  <div class="lang-header">
    <h3>C#</h3>
    <span class="lang-meta">ASP.NET Core + EF Core &middot; Port 5002</span>
  </div>
  <p>EF Core uses POCO model classes configured via a Fluent API in <code>DbContext.OnModelCreating()</code>. Queries use LINQ with async methods.</p>

<pre><code>public class TodoList {
    public int Id { get; set; }
    [Required] [StringLength(100)]
    public string Name { get; set; } = string.Empty;
    public List&lt;TodoItem&gt; Todos { get; set; } = new();
}

// Fluent API
entity.HasOne(e =&gt; e.List)
      .WithMany(l =&gt; l.Todos)
      .OnDelete(DeleteBehavior.Cascade);

// LINQ queries
var lists = await _db.Lists.Include(l =&gt; l.Todos)
    .OrderBy(l =&gt; l.CreatedAt).ToListAsync();
var list = await _db.Lists.FindAsync(id);

// CRUD
_db.Lists.Add(new TodoList { Name = name });
await _db.SaveChangesAsync();
_db.Lists.Remove(list);
await _db.SaveChangesAsync();</code></pre>
</div>

<!-- Rust -->
<div class="lang-section">
  <div class="lang-header">
    <h3>Rust</h3>
    <span class="lang-meta">Axum + SQLx &middot; Port 5003</span>
  </div>
  <p>SQLx maps SQL rows directly to Rust structs via <code>#[derive(FromRow)]</code>. Queries are raw SQL with typed <code>.bind()</code> parameters.</p>

<pre><code>#[derive(Debug, FromRow)]
struct TodoList {
    id: i64,
    name: String,
    created_at: Option&lt;String&gt;,
}

// Queries
let list: TodoList = sqlx::query_as(
    "SELECT id, name, created_at FROM lists WHERE id = ?"
).bind(id).fetch_one(&amp;pool).await?;

// CRUD
sqlx::query("INSERT INTO lists (name) VALUES (?)")
    .bind(&amp;name).execute(&amp;pool).await?;
sqlx::query("UPDATE todos SET completed = ? WHERE id = ?")
    .bind(!completed).bind(id).execute(&amp;pool).await?;
sqlx::query("DELETE FROM todos WHERE id = ?")
    .bind(id).execute(&amp;pool).await?;</code></pre>
</div>

<!-- Java -->
<div class="lang-section">
  <div class="lang-header">
    <h3>Java</h3>
    <span class="lang-meta">Spring Boot + JPA &middot; Port 5004</span>
  </div>
  <p>JPA uses <code>@Entity</code> annotations. Spring Data generates repository implementations from interface method names&mdash;just name a method and Spring writes the SQL.</p>

<pre><code>@Entity @Table(name = "todos")
public class TodoItem {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(nullable = false)
    private String title;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "list_id")
    private TodoList list;
}

// Derived query: Spring generates SQL from the method name
@Repository
public interface TodoItemRepository extends JpaRepository&lt;TodoItem, Long&gt; {
    List&lt;TodoItem&gt; findByListIdOrderByCreatedAtAsc(Long listId);
}

// CRUD
listRepository.save(new TodoList(name));
item.setCompleted(!item.getCompleted());
itemRepository.save(item);
listRepository.deleteById(id);</code></pre>
</div>

<!-- Lua -->
<div class="lang-section">
  <div class="lang-header">
    <h3>Lua</h3>
    <span class="lang-meta">LuaSocket + lsqlite3 &middot; Port 5005</span>
  </div>
  <p>Lua has no ORM. The <code>db.lua</code> module wraps raw SQLite3 calls with prepared statements and manual row mapping&mdash;the most bare-metal approach.</p>

<pre><code>function db.lists_get_by_id(id)
    local stmt = conn:prepare("SELECT id, name FROM lists WHERE id = ?")
    stmt:bind_values(id)
    local result = nil
    if stmt:step() == sqlite3.ROW then
        result = { id = stmt:get_value(0), name = stmt:get_value(1) }
    end
    stmt:finalize()
    return result
end

-- Toggle: arithmetic flip (1 - 0 = 1, 1 - 1 = 0)
function db.todos_toggle(id)
    local stmt = conn:prepare("UPDATE todos SET completed = 1 - completed WHERE id = ?")
    stmt:bind_values(id)
    stmt:step()
    stmt:finalize()
end</code></pre>
</div>

<h2>Querying API Comparison</h2>

<h3>Abstraction Levels</h3>
<table class="summary-table">
  <thead>
    <tr><th>Language</th><th>Abstraction</th><th>Query Style</th><th>Type Safety</th><th>Relationships</th></tr>
  </thead>
  <tbody>
    <tr><td>JS</td><td>None (raw SQL)</td><td>Sync prepared statements</td><td>None</td><td>Manual transaction</td></tr>
    <tr><td>Python</td><td>High</td><td>Fluent ORM API</td><td>Runtime</td><td><code>relationship()</code></td></tr>
    <tr><td>C#</td><td>High</td><td>LINQ expressions</td><td>Compile-time</td><td>Fluent API</td></tr>
    <tr><td>Rust</td><td>Low (mapper)</td><td>Raw SQL + bind</td><td>Compile-time</td><td>Manual / DDL</td></tr>
    <tr><td>Java</td><td>High</td><td>Derived query methods</td><td>Compile-time</td><td>JPA annotations</td></tr>
    <tr><td>Lua</td><td>None (raw SQL)</td><td>Prepared statements</td><td>None</td><td>DDL foreign keys</td></tr>
  </tbody>
</table>

<h3>SELECT by ID</h3>
<table>
  <thead><tr><th>Language</th><th>Code</th></tr></thead>
  <tbody>
    <tr><td>JS</td><td><code>db.prepare('SELECT * FROM lists WHERE id = ?').get(id)</code></td></tr>
    <tr><td>Python</td><td><code>db.get_or_404(List, list_id)</code></td></tr>
    <tr><td>C#</td><td><code>await _db.Lists.FindAsync(id)</code></td></tr>
    <tr><td>Rust</td><td><code>sqlx::query_as("...WHERE id = ?").bind(id).fetch_one(&amp;pool).await?</code></td></tr>
    <tr><td>Java</td><td><code>listRepository.findById(id).orElse(null)</code></td></tr>
    <tr><td>Lua</td><td><code>stmt:bind_values(id); stmt:step(); stmt:get_value(0)</code></td></tr>
  </tbody>
</table>

<h3>INSERT</h3>
<table>
  <thead><tr><th>Language</th><th>Code</th></tr></thead>
  <tbody>
    <tr><td>JS</td><td><code>db.prepare('INSERT INTO lists (name) VALUES (?)').run(name)</code></td></tr>
    <tr><td>Python</td><td><code>db.session.add(List(name="Work")); db.session.commit()</code></td></tr>
    <tr><td>C#</td><td><code>_db.Lists.Add(new TodoList { Name = name }); await _db.SaveChangesAsync()</code></td></tr>
    <tr><td>Rust</td><td><code>sqlx::query("INSERT INTO lists (name) VALUES (?)").bind(&amp;name).execute(&amp;pool).await?</code></td></tr>
    <tr><td>Java</td><td><code>listRepository.save(new TodoList(name))</code></td></tr>
    <tr><td>Lua</td><td><code>stmt = conn:prepare("INSERT INTO lists (name) VALUES (?)"); stmt:bind_values(name); stmt:step()</code></td></tr>
  </tbody>
</table>

<h3>UPDATE (Toggle)</h3>
<table>
  <thead><tr><th>Language</th><th>Code</th></tr></thead>
  <tbody>
    <tr><td>JS</td><td><code>db.prepare('UPDATE todos SET completed = CASE WHEN completed = 1 THEN 0 ELSE 1 END WHERE id = ?').run(id)</code></td></tr>
    <tr><td>Python</td><td><code>todo.completed = not todo.completed; db.session.commit()</code></td></tr>
    <tr><td>C#</td><td><code>todo.Completed = !todo.Completed; await _db.SaveChangesAsync()</code></td></tr>
    <tr><td>Rust</td><td><code>sqlx::query("UPDATE todos SET completed = ? WHERE id = ?").bind(!completed).bind(id).execute(&amp;pool).await?</code></td></tr>
    <tr><td>Java</td><td><code>item.setCompleted(!item.getCompleted()); itemRepository.save(item)</code></td></tr>
    <tr><td>Lua</td><td><code>conn:prepare("UPDATE todos SET completed = 1 - completed WHERE id = ?"):bind_values(id)</code></td></tr>
  </tbody>
</table>

<h3>DELETE with Cascades</h3>
<table>
  <thead><tr><th>Language</th><th>Cascade Mechanism</th><th>Code</th></tr></thead>
  <tbody>
    <tr><td>JS</td><td>Manual transaction</td><td><code>db.transaction(() => { deleteTodos(id); deleteList(id); })()</code></td></tr>
    <tr><td>Python</td><td><code>cascade="all, delete-orphan"</code></td><td><code>db.session.delete(lst); db.session.commit()</code></td></tr>
    <tr><td>C#</td><td><code>OnDelete(Cascade)</code></td><td><code>_db.Lists.Remove(list); await _db.SaveChangesAsync()</code></td></tr>
    <tr><td>Rust</td><td>Manual (two queries)</td><td><code>DELETE todos WHERE list_id=?; DELETE lists WHERE id=?</code></td></tr>
    <tr><td>Java</td><td><code>@OneToMany(cascade=ALL)</code></td><td><code>listRepository.deleteById(id)</code></td></tr>
    <tr><td>Lua</td><td>DDL <code>ON DELETE CASCADE</code></td><td><code>conn:prepare("DELETE FROM lists WHERE id = ?")</code></td></tr>
  </tbody>
</table>

<p>The spectrum runs from <strong>Java</strong> (most abstract&mdash;name a method and Spring generates the query) through <strong>Python/C#</strong> (fluent ORM APIs) to <strong>Rust</strong> (type-safe SQL mapper) to <strong>JS/Lua</strong> (raw prepared statements with manual row mapping).</p>

<h2>The Pipeline</h2>

<p>When code is pushed to the ormery repo, a CI/CD pipeline automatically compiles the Temper source, distributes the compiled output to language-specific library repos, and notifies the demo app repos of the update.</p>

<div class="pipeline-diagram">
  ormery (push to main)
    |
    v
  GitHub Actions: publish-libs.yml
    |
    +-- temper build (JDK 21 + Gradle)
    |       produces temper.out/{js,py,csharp,rust,java,lua}/
    |
    +-- Matrix: 6 parallel jobs (one per language)
            |
            +--&gt; ormery-js       (ormery/ subdir only)
            +--&gt; ormery-py       (ormery/ subdir only)
            +--&gt; ormery-csharp   (full tree: ormery + std + temper-core)
            +--&gt; ormery-rust     (full tree: ormery + std + temper-core)
            +--&gt; ormery-java     (ormery/ subdir only)
            +--&gt; ormery-lua      (ormery/ subdir only)
                    |
                    v
              Each lib repo has: notify-app.yml
                    |
                    +--&gt; ormery-js-app
                    +--&gt; ormery-py-app
                    +--&gt; ormery-csharp-app
                    +--&gt; ormery-rust-app
                    +--&gt; ormery-java-app
                    +--&gt; ormery-lua-app</div>

<p><strong>Why two tiers?</strong> Rust and C# need the full <code>temper.out/{lang}/</code> tree because their package files use local path dependencies (<code>path = "../temper-core"</code>). The other four languages use registry dependencies and only need the <code>ormery/</code> subdirectory.</p>

<p><strong>Authentication:</strong> Cross-repo pushes use SSH deploy keys (not PATs). Each target repo has a deploy key with write access. The private keys are stored as GitHub Actions secrets on the source repo. This is the same pattern used by <a href="https://github.com/notactuallytreyanastasio/deciduous">Deciduous</a> for its Homebrew tap.</p>

<h3>Workflow Details</h3>

<p><strong>Tier 1: <code>publish-libs.yml</code></strong> (on ormery) &mdash; Triggered on push to main. Clones the Temper compiler, builds it with Gradle, runs <code>temper build</code> to produce <code>temper.out/</code>, then syncs each language's compiled output to its lib repo via SSH.</p>

<p><strong>Tier 2: <code>notify-app.yml</code></strong> (on each lib repo) &mdash; Triggered when the lib repo receives a push. Clones the corresponding app repo via SSH and bumps the <code>LIB_VERSION</code> file to record the new lib commit SHA.</p>

<h2>Repositories</h2>

<h3>Compiled Libraries</h3>
<p>These repos contain the compiled Temper output for each target language. They are automatically updated by the pipeline.</p>
<table>
  <thead><tr><th>Repo</th><th>Language</th><th>Contents</th></tr></thead>
  <tbody>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-js">ormery-js</a></td><td>JavaScript</td><td>ormery/ subdir</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-py">ormery-py</a></td><td>Python</td><td>ormery/ subdir</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-csharp">ormery-csharp</a></td><td>C#</td><td>Full tree (path deps)</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-rust">ormery-rust</a></td><td>Rust</td><td>Full tree (path deps)</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-java">ormery-java</a></td><td>Java</td><td>ormery/ subdir</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-lua">ormery-lua</a></td><td>Lua</td><td>ormery/ subdir</td></tr>
  </tbody>
</table>

<h3>Demo Apps</h3>
<p>Retro-styled todo list managers demonstrating ORMery in each language's web ecosystem.</p>
<table>
  <thead><tr><th>Repo</th><th>Stack</th><th>Port</th></tr></thead>
  <tbody>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-js-app">ormery-js-app</a></td><td>Express + better-sqlite3 + EJS</td><td>5006</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-py-app">ormery-py-app</a></td><td>Flask + SQLAlchemy + Jinja2</td><td>5001</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-csharp-app">ormery-csharp-app</a></td><td>ASP.NET Core + EF Core + Razor</td><td>5002</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-rust-app">ormery-rust-app</a></td><td>Axum + SQLx + Askama</td><td>5003</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-java-app">ormery-java-app</a></td><td>Spring Boot + JPA + Thymeleaf</td><td>5004</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-lua-app">ormery-lua-app</a></td><td>LuaSocket + lsqlite3</td><td>5005</td></tr>
  </tbody>
</table>

<footer>
  <p>
    Built with <a href="https://github.com/temperlang/temper">Temper</a> &middot;
    SQL escaping by <a href="https://github.com/nickreserved/secure-composition">secure-composition</a> &middot;
    Decision tracking via <a href="https://github.com/notactuallytreyanastasio/deciduous">Deciduous</a> &middot;
    Source: <a href="https://github.com/notactuallytreyanastasio/ormery">ormery</a>
  </p>
</footer>

</div>
</body>
</html>
