<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ORMery - A Multi-Language ORM from Temper</title>
  <meta name="description" content="ORMery is a query builder and ORM written in Temper that compiles to 6 languages. See how the same ORM looks in JavaScript, Python, C#, Rust, Java, and Lua.">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color: #1a1a1a;
      background: #fff;
      line-height: 1.7;
      font-size: 16px;
    }
    .container {
      max-width: 720px;
      margin: 0 auto;
      padding: 3rem 1.5rem 4rem;
    }
    h1 {
      font-size: 2.4rem;
      font-weight: 700;
      margin-bottom: 0.25rem;
      letter-spacing: -0.02em;
    }
    .subtitle {
      color: #666;
      font-size: 1.1rem;
      margin-bottom: 2.5rem;
    }
    h2 {
      font-size: 1.5rem;
      font-weight: 600;
      margin-top: 3rem;
      margin-bottom: 0.75rem;
      padding-bottom: 0.3rem;
      border-bottom: 1px solid #e5e5e5;
    }
    h3 {
      font-size: 1.15rem;
      font-weight: 600;
      margin-top: 2rem;
      margin-bottom: 0.5rem;
    }
    p { margin-bottom: 1rem; }
    a { color: #0066cc; text-decoration: none; }
    a:hover { text-decoration: underline; }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0 1.5rem;
      font-size: 0.9rem;
    }
    th, td {
      text-align: left;
      padding: 0.5rem 0.75rem;
      border: 1px solid #e0e0e0;
    }
    th {
      background: #f7f7f7;
      font-weight: 600;
    }
    tr:nth-child(even) td { background: #fafafa; }
    pre {
      background: #f5f5f5;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 0.75rem 1rem;
      overflow-x: auto;
      margin: 0.75rem 0 1.25rem;
      font-size: 0.85rem;
      line-height: 1.5;
    }
    code {
      font-family: "SF Mono", "Fira Code", "Fira Mono", Menlo, Consolas, monospace;
      font-size: 0.88em;
    }
    p code, li code, td code {
      background: #f0f0f0;
      padding: 0.15em 0.35em;
      border-radius: 3px;
    }
    .pipeline-diagram {
      background: #f9f9f9;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 1.5rem;
      margin: 1rem 0 1.5rem;
      font-family: "SF Mono", "Fira Code", Menlo, Consolas, monospace;
      font-size: 0.82rem;
      line-height: 1.6;
      white-space: pre;
      overflow-x: auto;
    }
    .lang-section {
      margin-top: 1.5rem;
      padding-top: 1rem;
      border-top: 1px solid #eee;
    }
    .lang-section:first-of-type { border-top: none; padding-top: 0; }
    .lang-header {
      display: flex;
      align-items: baseline;
      gap: 0.75rem;
      margin-bottom: 0.25rem;
    }
    .lang-header h3 { margin-top: 0; margin-bottom: 0; }
    .lang-meta { color: #888; font-size: 0.85rem; }
    footer {
      margin-top: 4rem;
      padding-top: 1.5rem;
      border-top: 1px solid #e0e0e0;
      color: #888;
      font-size: 0.85rem;
    }
    footer a { color: #666; }
    .summary-table td:first-child { font-weight: 600; }
    .note {
      background: #f0f7ff;
      border-left: 3px solid #0066cc;
      padding: 0.75rem 1rem;
      margin: 1rem 0 1.5rem;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
<div class="container">

<h1>ORMery</h1>
<p class="subtitle">A query builder and ORM written in <a href="https://github.com/temperlang/temper">Temper</a> that compiles to six languages.</p>

<p>
  <a href="https://github.com/temperlang/temper">Temper</a> is a programming language that compiles to JavaScript, Python, C#, Rust, Java, and Lua. ORMery is a query builder written in Temper that produces injection-proof SQL via contextual autoescaping. Write one ORM in Temper, get a native library for every target language&mdash;with the same API surface, the same safety guarantees, and the same generated SQL.
</p>
<p>
  To demonstrate how ORMery works across all six target languages, we built a retro-styled todo list app in each one. Every app uses ORMery for schema definition, SELECT queries, and INSERT operations, with a thin SQLite driver for execution. This page documents the demo apps, shows ORMery's API side by side in each language, and explains the CI/CD pipeline that keeps everything in sync.
</p>

<h2>What ORMery Provides</h2>

<p>ORMery is a <strong>query builder</strong> compiled from a single Temper source to six languages. It provides:</p>

<table>
  <thead><tr><th>Function</th><th>Purpose</th></tr></thead>
  <tbody>
    <tr><td><code>schema(name, fields)</code></td><td>Define a table schema (auto-adds <code>id</code> primary key)</td></tr>
    <tr><td><code>field(name, type, pk, nullable)</code></td><td>Define a column (<code>"String"</code> or <code>"Int"</code>)</td></tr>
    <tr><td><code>Query(schema, store)</code></td><td>Build SELECT queries with <code>.where()</code>, <code>.orderBy()</code>, <code>.limit()</code></td></tr>
    <tr><td><code>toInsertSql(schema, values)</code></td><td>Generate INSERT statements with autoescaped values</td></tr>
    <tr><td><code>InMemoryStore</code></td><td>In-memory data store (also used as dummy arg for SQL-only generation)</td></tr>
  </tbody>
</table>

<div class="note">
  <strong>Security by default:</strong> All string values are autoescaped through ORMery's <code>SqlFragment</code> type. Table and column names are validated against an allowlist of safe identifiers. SQL injection is structurally impossible.
</div>

<p>ORMery does <strong>not</strong> generate UPDATE, DELETE, or DDL (CREATE TABLE) SQL, nor does it support JOINs or aggregates. The demo apps use raw parameterized SQL for those operations.</p>

<h2>Demo Apps</h2>

<p>Each app is a todo list manager with lists and todos, styled to look like Mac System 6 with Windows 95 windows. Same features, same schema, six different stacks&mdash;all powered by the same ORMery query builder.</p>

<table>
  <thead>
    <tr><th>Language</th><th>Web Framework</th><th>DB Driver</th><th>Port</th><th>Repo</th></tr>
  </thead>
  <tbody>
    <tr><td>JavaScript</td><td>Express + EJS</td><td>ORMery + better-sqlite3</td><td>5006</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-js-app">ormery-js-app</a></td></tr>
    <tr><td>Python</td><td>Flask + Jinja2</td><td>ORMery + sqlite3</td><td>5001</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-py-app">ormery-py-app</a></td></tr>
    <tr><td>C#</td><td>ASP.NET Core Razor</td><td>ORMery + Microsoft.Data.Sqlite</td><td>5002</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-csharp-app">ormery-csharp-app</a></td></tr>
    <tr><td>Rust</td><td>Axum + Askama</td><td>ORMery + rusqlite</td><td>5003</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-rust-app">ormery-rust-app</a></td></tr>
    <tr><td>Java</td><td>Spring Boot + Thymeleaf</td><td>ORMery + JDBC</td><td>5004</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-java-app">ormery-java-app</a></td></tr>
    <tr><td>Lua</td><td>LuaSocket (hand-rolled)</td><td>ORMery + lsqlite3</td><td>5005</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-lua-app">ormery-lua-app</a></td></tr>
  </tbody>
</table>

<h2>ORMery API in Each Language</h2>

<p>Every app defines the same two schemas and uses the same ORMery operations. Here is how the API looks in each language.</p>

<!-- JS -->
<div class="lang-section">
  <div class="lang-header">
    <h3>JavaScript</h3>
    <span class="lang-meta">Express + better-sqlite3 &middot; Port 5006</span>
  </div>
  <p>The JS app uses ESM imports. ORMery is vendored via <code>file:</code> protocol dependencies in <code>package.json</code>. Queries are generated by ORMery and executed with better-sqlite3's synchronous API.</p>

<pre><code>import { schema, field, Query, InMemoryStore, toInsertSql } from 'ormery';

const store = new InMemoryStore();

const listSchema = schema("lists", [
  field("name", "String", false, false),
  field("created_at", "String", false, true),
]);

const todoSchema = schema("todos", [
  field("title", "String", false, false),
  field("completed", "Int", false, false),
  field("list_id", "Int", false, false),
  field("created_at", "String", false, true),
]);

// SELECT with WHERE (ORMery)
const sql = new Query(listSchema, store)
  .where("id", "=", String(id)).toSql().toString();
const list = db.prepare(sql).get();

// INSERT (ORMery)
const vals = new Map([["name", name]]);
const insertSql = toInsertSql(listSchema, vals).toString();
db.prepare(insertSql).run();

// UPDATE (raw SQL - ORMery doesn't generate UPDATE)
stmts.toggleTodo.run(id);</code></pre>
</div>

<!-- Python -->
<div class="lang-section">
  <div class="lang-header">
    <h3>Python</h3>
    <span class="lang-meta">Flask + sqlite3 &middot; Port 5001</span>
  </div>
  <p>The Python app uses the stdlib <code>sqlite3</code> module (no SQLAlchemy). ORMery is imported from vendor directories via <code>sys.path</code>. Value maps for inserts are built using <code>temper_core.Pair</code> and <code>map_constructor</code>.</p>

<pre><code>from ormery.ormery import schema, field, Query, InMemoryStore, to_insert_sql
from temper_core import Pair, map_constructor

store = InMemoryStore()
list_schema = schema("lists", [
    field("name", "String", False, False),
    field("created_at", "String", False, True),
])

# SELECT with WHERE + ORDER BY (ORMery)
sql = (Query(todo_schema, store)
    .where("list_id", "=", str(list_id))
    .order_by("completed", "asc")
    .order_by("created_at", "desc")
    .to_sql().to_string())
todos = conn.execute(sql).fetchall()

# INSERT (ORMery)
vals = map_constructor([Pair("name", name)])
sql = to_insert_sql(list_schema, vals).to_string()
conn.execute(sql)

# UPDATE (raw SQL)
conn.execute("UPDATE todos SET completed = ? WHERE id = ?",
             (new_val, todo_id))</code></pre>
</div>

<!-- C# -->
<div class="lang-section">
  <div class="lang-header">
    <h3>C#</h3>
    <span class="lang-meta">ASP.NET Core + Microsoft.Data.Sqlite &middot; Port 5002</span>
  </div>
  <p>The C# app uses Microsoft.Data.Sqlite (no EF Core). ORMery is referenced via <code>ProjectReference</code> to the vendored <code>Ormery.csproj</code>. Value maps use <code>Mapped.ConstructMap</code> with <code>Listed.CreateReadOnlyList</code>.</p>

<pre><code>using Ormery;
using TemperLang.Core;

var listSchema = OrmeryGlobal.Schema("lists",
    Listed.CreateReadOnlyList&lt;Field&gt;(
        OrmeryGlobal.Field("name", "String", false, false),
        OrmeryGlobal.Field("created_at", "String", false, false)
    ));

// SELECT with WHERE (ORMery)
var query = new Query(ListSchema, _dummyStore)
    .Where("id", "=", id.ToString());
string sql = query.ToSql().ToString();
var list = cmd.ExecuteReader();

// INSERT (ORMery)
var values = Mapped.ConstructMap(
    Listed.CreateReadOnlyList&lt;KeyValuePair&lt;string, string&gt;&gt;(
        new KeyValuePair&lt;string, string&gt;("name", name),
        new KeyValuePair&lt;string, string&gt;("created_at", now)
    ));
string sql = OrmeryGlobal.ToInsertSql(ListSchema, values).ToString();

// UPDATE (raw SQL with SqlBuilder for safe escaping)
var sb = new SqlBuilder();
sb.AppendSafe("UPDATE lists SET name = ");
sb.AppendString(name);
sb.AppendSafe(" WHERE id = ");
sb.AppendInt32(id);</code></pre>
</div>

<!-- Rust -->
<div class="lang-section">
  <div class="lang-header">
    <h3>Rust</h3>
    <span class="lang-meta">Axum + rusqlite &middot; Port 5003</span>
  </div>
  <p>The Rust app uses rusqlite (no SQLx). ORMery is a path dependency in <code>Cargo.toml</code>. Note <code>r#where</code>&mdash;<code>where</code> is a Rust keyword, so the raw identifier syntax is required.</p>

<pre><code>use ormery::{schema, field, Query, InMemoryStore, to_insert_sql};

let list_schema = schema("lists".to_string(), vec![
    field("name".to_string(), "String".to_string(), false, false),
    field("created_at".to_string(), "String".to_string(), false, true),
]);

// SELECT with WHERE (ORMery) - note r#where for Rust keyword
let sql = Query::new(list_schema.clone(), store.clone())
    .r#where("id", "=", id.to_string())
    .to_sql().to_string().to_string();
let list = conn.query_row(&amp;sql, [], |row| { ... })?;

// INSERT (ORMery)
let values = temper_core::Map::new(&amp;[
    (Arc::new("name".to_string()), Arc::new(name.to_string())),
]);
let sql = to_insert_sql(list_schema.clone(), values)
    .to_string().to_string();
conn.execute(&amp;sql, [])?;

// UPDATE (raw SQL)
conn.execute("UPDATE todos SET completed = ?1 WHERE id = ?2",
    rusqlite::params![!completed as i64, id])?;</code></pre>
</div>

<!-- Java -->
<div class="lang-section">
  <div class="lang-header">
    <h3>Java</h3>
    <span class="lang-meta">Spring Boot + JDBC &middot; Port 5004</span>
  </div>
  <p>The Java app uses Spring JDBC (no JPA). ORMery source is compiled as an additional Maven source directory. Value maps use <code>ormery.MapConstructor</code>.</p>

<pre><code>import ormery.OrmeryGlobal;
import ormery.Query;
import ormery.Schema;
import ormery.InMemoryStore;

Schema listSchema = OrmeryGlobal.schema("lists", List.of(
    OrmeryGlobal.field("name", "String", false, false),
    OrmeryGlobal.field("created_at", "String", false, true)
));

// SELECT with WHERE + ORDER BY (ORMery)
String sql = new Query(todoSchema, store)
    .where("list_id", "=", String.valueOf(listId))
    .orderBy("completed", "asc")
    .orderBy("created_at", "desc")
    .toSql().toString();
List&lt;TodoItem&gt; todos = jdbc.query(sql, todoRowMapper);

// INSERT (ORMery)
var values = MapConstructor.construct(List.of(
    new Pair&lt;&gt;("name", name),
    new Pair&lt;&gt;("created_at", now)
));
String sql = OrmeryGlobal.toInsertSql(listSchema, values).toString();
jdbc.update(sql);

// UPDATE (raw SQL)
jdbc.update("UPDATE todos SET completed = CASE WHEN completed = 0 "
    + "THEN 1 ELSE 0 END WHERE id = ?", id);</code></pre>
</div>

<!-- Lua -->
<div class="lang-section">
  <div class="lang-header">
    <h3>Lua</h3>
    <span class="lang-meta">LuaSocket + lsqlite3 &middot; Port 5005</span>
  </div>
  <p>The Lua app loads ORMery via <code>package.path</code> from vendor directories. Helper functions wrap ORMery's API for the Lua-idiomatic table-based style.</p>

<pre><code>local ormery = require('ormery.init')

local list_schema = ormery.schema("lists", {
    ormery.field("name", "String", false, false),
    ormery.field("created_at", "String", false, true),
})

-- SELECT with WHERE + ORDER BY (ORMery)
local sql = ormery.Query(todo_schema, store)
    :where("list_id", "=", tostring(list_id))
    :order_by("completed", "asc")
    :order_by("created_at", "desc")
    :to_sql():to_string()
local stmt = conn:prepare(sql)

-- INSERT (ORMery)
local values = make_values({name = name})
local sql = ormery.to_insert_sql(list_schema, values):to_string()
conn:exec(sql)

-- UPDATE (raw SQL)
local stmt = conn:prepare(
    "UPDATE todos SET completed = 1 - completed WHERE id = ?")
stmt:bind_values(id)</code></pre>
</div>

<h2>Querying API Comparison</h2>

<p>Because ORMery is compiled from the same Temper source, the API is structurally identical across all six languages&mdash;only the syntax changes to match each language's conventions.</p>

<h3>Schema Definition</h3>
<table>
  <thead><tr><th>Language</th><th>Code</th></tr></thead>
  <tbody>
    <tr><td>JS</td><td><code>schema("lists", [field("name", "String", false, false)])</code></td></tr>
    <tr><td>Python</td><td><code>schema("lists", [field("name", "String", False, False)])</code></td></tr>
    <tr><td>C#</td><td><code>OrmeryGlobal.Schema("lists", Listed.CreateReadOnlyList&lt;Field&gt;(OrmeryGlobal.Field(...)))</code></td></tr>
    <tr><td>Rust</td><td><code>schema("lists".to_string(), vec![field("name".to_string(), ...)])</code></td></tr>
    <tr><td>Java</td><td><code>OrmeryGlobal.schema("lists", List.of(OrmeryGlobal.field(...)))</code></td></tr>
    <tr><td>Lua</td><td><code>ormery.schema("lists", {ormery.field("name", "String", false, false)})</code></td></tr>
  </tbody>
</table>

<h3>SELECT with WHERE</h3>
<table>
  <thead><tr><th>Language</th><th>Code</th></tr></thead>
  <tbody>
    <tr><td>JS</td><td><code>new Query(schema, store).where("id", "=", String(id)).toSql().toString()</code></td></tr>
    <tr><td>Python</td><td><code>Query(schema, store).where("id", "=", str(id)).to_sql().to_string()</code></td></tr>
    <tr><td>C#</td><td><code>new Query(schema, store).Where("id", "=", id.ToString()).ToSql().ToString()</code></td></tr>
    <tr><td>Rust</td><td><code>Query::new(schema, store).r#where("id", "=", id.to_string()).to_sql().to_string()</code></td></tr>
    <tr><td>Java</td><td><code>new Query(schema, store).where("id", "=", String.valueOf(id)).toSql().toString()</code></td></tr>
    <tr><td>Lua</td><td><code>ormery.Query(schema, store):where("id", "=", tostring(id)):to_sql():to_string()</code></td></tr>
  </tbody>
</table>

<h3>INSERT</h3>
<table>
  <thead><tr><th>Language</th><th>Code</th></tr></thead>
  <tbody>
    <tr><td>JS</td><td><code>toInsertSql(schema, new Map([["name", name]])).toString()</code></td></tr>
    <tr><td>Python</td><td><code>to_insert_sql(schema, map_constructor([Pair("name", name)])).to_string()</code></td></tr>
    <tr><td>C#</td><td><code>OrmeryGlobal.ToInsertSql(schema, Mapped.ConstructMap(Listed.CreateReadOnlyList&lt;KVP&gt;(...))).ToString()</code></td></tr>
    <tr><td>Rust</td><td><code>to_insert_sql(schema, Map::new(&amp;[(Arc::new("name".into()), Arc::new(name))])).to_string()</code></td></tr>
    <tr><td>Java</td><td><code>OrmeryGlobal.toInsertSql(schema, MapConstructor.construct(List.of(new Pair&lt;&gt;(...)))).toString()</code></td></tr>
    <tr><td>Lua</td><td><code>ormery.to_insert_sql(schema, make_values({name = name})):to_string()</code></td></tr>
  </tbody>
</table>

<h3>What ORMery Handles vs. Raw SQL</h3>
<table class="summary-table">
  <thead>
    <tr><th>Operation</th><th>ORMery?</th><th>Notes</th></tr>
  </thead>
  <tbody>
    <tr><td>SELECT</td><td>Yes</td><td><code>Query.where().orderBy().limit().toSql()</code></td></tr>
    <tr><td>INSERT</td><td>Yes</td><td><code>toInsertSql(schema, values)</code> with autoescaped values</td></tr>
    <tr><td>UPDATE</td><td>No</td><td>Raw parameterized SQL or <code>SqlBuilder</code></td></tr>
    <tr><td>DELETE</td><td>No</td><td>Raw parameterized SQL or <code>SqlBuilder</code></td></tr>
    <tr><td>CREATE TABLE</td><td>No</td><td>Raw DDL</td></tr>
    <tr><td>JOINs / Aggregates</td><td>No</td><td>Raw SQL (COUNT, SUM, LEFT JOIN)</td></tr>
  </tbody>
</table>

<h2>The Pipeline</h2>

<p>When code is pushed to the ormery repo, a CI/CD pipeline automatically compiles the Temper source, distributes the compiled output to language-specific library repos, and notifies the demo app repos of the update.</p>

<div class="pipeline-diagram">
  ormery (push to main)
    |
    v
  GitHub Actions: publish-libs.yml
    |
    +-- temper build (JDK 21 + Gradle)
    |       produces temper.out/{js,py,csharp,rust,java,lua}/
    |
    +-- Matrix: 6 parallel jobs (one per language)
            |
            +--&gt; ormery-js       (full tree: ormery + std + temper-core)
            +--&gt; ormery-py       (full tree: ormery + std + temper-core)
            +--&gt; ormery-csharp   (full tree: ormery + std + temper-core)
            +--&gt; ormery-rust     (full tree: ormery + std + temper-core)
            +--&gt; ormery-java     (full tree: ormery + std + temper-core)
            +--&gt; ormery-lua      (full tree: ormery + std + temper-core)
                    |
                    v
              Each lib repo has: notify-app.yml
                    |
                    +--&gt; ormery-js-app
                    +--&gt; ormery-py-app
                    +--&gt; ormery-csharp-app
                    +--&gt; ormery-rust-app
                    +--&gt; ormery-java-app
                    +--&gt; ormery-lua-app</div>

<p><strong>Full tree for all languages:</strong> Every lib repo receives the complete <code>temper.out/{lang}/</code> tree containing <code>ormery/</code>, <code>std/</code>, and <code>temper-core/</code>. This ensures the vendored ORMery library and its Temper runtime dependencies resolve correctly in every language ecosystem.</p>

<p><strong>Vendoring:</strong> Each demo app vendors the compiled ORMery library in a <code>vendor/</code> directory. The app's build system references vendor paths directly (e.g., <code>"ormery": "file:./vendor/ormery"</code> in JS, <code>path = "vendor/ormery"</code> in Rust, <code>ProjectReference</code> in C#). When the pipeline updates a lib repo, the app repo pulls the latest compiled output into its vendor directory.</p>

<p><strong>Authentication:</strong> Cross-repo pushes use SSH deploy keys (not PATs). Each target repo has a deploy key with write access. The private keys are stored as GitHub Actions secrets on the source repo. This is the same pattern used by <a href="https://github.com/notactuallytreyanastasio/deciduous">Deciduous</a> for its Homebrew tap.</p>

<h3>Workflow Details</h3>

<p><strong>Tier 1: <code>publish-libs.yml</code></strong> (on ormery) &mdash; Triggered on push to main. Clones the Temper compiler, builds it with Gradle, runs <code>temper build</code> to produce <code>temper.out/</code>, then syncs each language's compiled output to its lib repo via SSH.</p>

<p><strong>Tier 2: <code>notify-app.yml</code></strong> (on each lib repo) &mdash; Triggered when the lib repo receives a push. Clones the corresponding app repo via SSH and updates the <code>vendor/</code> directory with the latest compiled ORMery output.</p>

<h2>Repositories</h2>

<h3>Compiled Libraries</h3>
<p>These repos contain the compiled Temper output for each target language. They are automatically updated by the pipeline.</p>
<table>
  <thead><tr><th>Repo</th><th>Language</th><th>Contents</th></tr></thead>
  <tbody>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-js">ormery-js</a></td><td>JavaScript</td><td>Full tree (ormery + std + temper-core)</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-py">ormery-py</a></td><td>Python</td><td>Full tree (ormery + std + temper-core)</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-csharp">ormery-csharp</a></td><td>C#</td><td>Full tree (ormery + std + temper-core)</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-rust">ormery-rust</a></td><td>Rust</td><td>Full tree (ormery + std + temper-core)</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-java">ormery-java</a></td><td>Java</td><td>Full tree (ormery + std + temper-core)</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-lua">ormery-lua</a></td><td>Lua</td><td>Full tree (ormery + std + temper-core)</td></tr>
  </tbody>
</table>

<h3>Demo Apps</h3>
<p>Retro-styled todo list managers demonstrating ORMery in each language's web ecosystem.</p>
<table>
  <thead><tr><th>Repo</th><th>Stack</th><th>Port</th></tr></thead>
  <tbody>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-js-app">ormery-js-app</a></td><td>Express + ORMery + better-sqlite3 + EJS</td><td>5006</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-py-app">ormery-py-app</a></td><td>Flask + ORMery + sqlite3 + Jinja2</td><td>5001</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-csharp-app">ormery-csharp-app</a></td><td>ASP.NET Core + ORMery + Microsoft.Data.Sqlite + Razor</td><td>5002</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-rust-app">ormery-rust-app</a></td><td>Axum + ORMery + rusqlite + Askama</td><td>5003</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-java-app">ormery-java-app</a></td><td>Spring Boot + ORMery + JDBC + Thymeleaf</td><td>5004</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-lua-app">ormery-lua-app</a></td><td>LuaSocket + ORMery + lsqlite3</td><td>5005</td></tr>
  </tbody>
</table>

<footer>
  <p>
    Built with <a href="https://github.com/temperlang/temper">Temper</a> &middot;
    SQL escaping via contextual autoescaping &middot;
    Decision tracking via <a href="https://github.com/notactuallytreyanastasio/deciduous">Deciduous</a> &middot;
    Source: <a href="https://github.com/notactuallytreyanastasio/ormery">ormery</a>
  </p>
</footer>

</div>
</body>
</html>
