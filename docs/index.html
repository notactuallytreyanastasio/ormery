<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ORMery - One ORM, Six Languages</title>
  <meta name="description" content="ORMery is a query builder written in Temper that compiles to JavaScript, Python, C#, Rust, Java, and Lua. One source, six native libraries, injection-proof SQL.">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color: #1a1a1a;
      background: #fff;
      line-height: 1.7;
      font-size: 16px;
    }
    .container {
      max-width: 780px;
      margin: 0 auto;
      padding: 3rem 1.5rem 4rem;
    }
    h1 {
      font-size: 2.4rem;
      font-weight: 700;
      margin-bottom: 0.25rem;
      letter-spacing: -0.02em;
    }
    .subtitle {
      color: #666;
      font-size: 1.1rem;
      margin-bottom: 2.5rem;
    }
    h2 {
      font-size: 1.5rem;
      font-weight: 600;
      margin-top: 3rem;
      margin-bottom: 0.75rem;
      padding-bottom: 0.3rem;
      border-bottom: 1px solid #e5e5e5;
    }
    h3 {
      font-size: 1.15rem;
      font-weight: 600;
      margin-top: 2rem;
      margin-bottom: 0.5rem;
    }
    p { margin-bottom: 1rem; }
    a { color: #0066cc; text-decoration: none; }
    a:hover { text-decoration: underline; }
    ul, ol { margin-bottom: 1rem; padding-left: 1.5rem; }
    li { margin-bottom: 0.25rem; }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0 1.5rem;
      font-size: 0.9rem;
    }
    th, td {
      text-align: left;
      padding: 0.5rem 0.75rem;
      border: 1px solid #e0e0e0;
    }
    th {
      background: #f7f7f7;
      font-weight: 600;
    }
    tr:nth-child(even) td { background: #fafafa; }
    pre {
      background: #f5f5f5;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 0.75rem 1rem;
      overflow-x: auto;
      margin: 0.75rem 0 1.25rem;
      font-size: 0.82rem;
      line-height: 1.5;
    }
    code {
      font-family: "SF Mono", "Fira Code", "Fira Mono", Menlo, Consolas, monospace;
      font-size: 0.88em;
    }
    p code, li code, td code {
      background: #f0f0f0;
      padding: 0.15em 0.35em;
      border-radius: 3px;
    }
    .pipeline-diagram {
      background: #f9f9f9;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 1.5rem;
      margin: 1rem 0 1.5rem;
      font-family: "SF Mono", "Fira Code", Menlo, Consolas, monospace;
      font-size: 0.8rem;
      line-height: 1.6;
      white-space: pre;
      overflow-x: auto;
    }
    .lang-section {
      margin-top: 1.5rem;
      padding-top: 1rem;
      border-top: 1px solid #eee;
    }
    .lang-section:first-of-type { border-top: none; padding-top: 0; }
    .lang-header {
      display: flex;
      align-items: baseline;
      gap: 0.75rem;
      margin-bottom: 0.25rem;
    }
    .lang-header h3 { margin-top: 0; margin-bottom: 0; }
    .lang-meta { color: #888; font-size: 0.85rem; }
    footer {
      margin-top: 4rem;
      padding-top: 1.5rem;
      border-top: 1px solid #e0e0e0;
      color: #888;
      font-size: 0.85rem;
    }
    footer a { color: #666; }
    .note {
      background: #f0f7ff;
      border-left: 3px solid #0066cc;
      padding: 0.75rem 1rem;
      margin: 1rem 0 1.5rem;
      font-size: 0.9rem;
    }
    .note-green {
      background: #f0faf0;
      border-left: 3px solid #2a7a2a;
      padding: 0.75rem 1rem;
      margin: 1rem 0 1.5rem;
      font-size: 0.9rem;
    }
    .summary-table td:first-child { font-weight: 600; white-space: nowrap; }
    .step-num {
      display: inline-block;
      background: #0066cc;
      color: white;
      width: 1.6em;
      height: 1.6em;
      line-height: 1.6em;
      text-align: center;
      border-radius: 50%;
      font-weight: 600;
      font-size: 0.85rem;
      margin-right: 0.5rem;
    }
  </style>
</head>
<body>
<div class="container">

<h1>ORMery</h1>
<p class="subtitle">One ORM, six languages. Written in <a href="https://github.com/temperlang/temper">Temper</a>, compiled everywhere.</p>

<p>
  <a href="https://github.com/temperlang/temper">Temper</a> is a programming language that compiles to JavaScript, Python, C#, Rust, Java, and Lua. ORMery is a query builder written in Temper that produces <strong>injection-proof SQL</strong> via contextual autoescaping. Write the ORM once in Temper, get a native library for every target language&mdash;same API surface, same safety guarantees, same generated SQL.
</p>

<p>
  Every demo app on this page is a real, working todo list manager. Each one uses the <em>same</em> ORMery library&mdash;compiled to its native language&mdash;for schema definition, SELECT queries, and INSERT operations. The code samples below are taken directly from the app source code.
</p>

<h2>The Idea</h2>

<p>Traditional cross-language projects rewrite their ORM in each target language. ORMery takes a different approach:</p>

<ol>
  <li>Write the query builder <strong>once</strong> in Temper</li>
  <li>Compile to six native libraries (JS, Python, C#, Rust, Java, Lua)</li>
  <li>Each app vendors the compiled library and calls it natively</li>
  <li>A CI/CD pipeline keeps all libraries and apps in sync automatically</li>
</ol>

<p>The result: one source of truth for query generation, six idiomatic implementations, and zero manual porting.</p>

<h2>ORMery API</h2>

<p>ORMery provides four core functions, available in every target language:</p>

<table>
  <thead><tr><th>Function</th><th>Purpose</th></tr></thead>
  <tbody>
    <tr><td><code>schema(name, fields)</code></td><td>Define a table schema (auto-adds <code>id</code> primary key)</td></tr>
    <tr><td><code>field(name, type, pk, nullable)</code></td><td>Define a column (<code>"String"</code> or <code>"Int"</code>)</td></tr>
    <tr><td><code>Query(schema, store)</code></td><td>Build SELECT queries: <code>.where()</code>, <code>.orderBy()</code>, <code>.limit()</code>, <code>.toSql()</code></td></tr>
    <tr><td><code>toInsertSql(schema, values)</code></td><td>Generate INSERT statements with autoescaped values</td></tr>
  </tbody>
</table>

<div class="note-green">
  <strong>Security by default:</strong> ORMery's <code>SqlFragment</code> type implements contextual autoescaping. String values are escaped through <code>SqlString</code> (single quotes doubled). Table and column names are validated against a strict identifier allowlist. SQL injection is structurally impossible&mdash;the type system prevents it.
</div>

<p>ORMery does <strong>not</strong> generate UPDATE, DELETE, or DDL (CREATE TABLE) SQL, nor does it support JOINs or aggregates. The demo apps use raw parameterized SQL for those operations.</p>

<h2>ORMery in Each Language</h2>

<p>Below are real code samples from the six demo apps. Every app defines the same two schemas (lists and todos) and uses ORMery for SELECT and INSERT queries.</p>

<!-- ═══════════════════════════ JS ═══════════════════════════ -->
<div class="lang-section">
  <div class="lang-header">
    <h3>JavaScript</h3>
    <span class="lang-meta">Express + better-sqlite3 &middot; Port 5006</span>
  </div>
  <p>ORMery is vendored via <code>"ormery": "file:./vendor/ormery"</code> in package.json. The app uses ESM imports.</p>

<pre><code>import { schema, field, Query, InMemoryStore, toInsertSql } from 'ormery';

const store = new InMemoryStore();

const listSchema = schema("lists", [
  field("name", "String", false, false),
  field("created_at", "String", false, true),
]);

const todoSchema = schema("todos", [
  field("title", "String", false, false),
  field("completed", "Int", false, false),
  field("list_id", "Int", false, false),
  field("created_at", "String", false, true),
]);</code></pre>

  <p><strong>SELECT</strong> &mdash; Build a query, get the SQL string, execute with better-sqlite3:</p>
<pre><code>// Get a single list by ID
const sql = new Query(listSchema, store)
  .where("id", "=", String(id)).toSql().toString();
const list = db.prepare(sql).get();

// Get todos for a list, ordered
const todosSql = new Query(todoSchema, store)
  .where("list_id", "=", String(id))
  .orderBy("completed", "asc")
  .orderBy("created_at", "desc")
  .toSql().toString();
const todos = db.prepare(todosSql).all();</code></pre>

  <p><strong>INSERT</strong> &mdash; Pass a Map of column values:</p>
<pre><code>const vals = new Map([["name", name]]);
const insertSql = toInsertSql(listSchema, vals).toString();
db.prepare(insertSql).run();</code></pre>
</div>

<!-- ═══════════════════════════ Python ═══════════════════════════ -->
<div class="lang-section">
  <div class="lang-header">
    <h3>Python</h3>
    <span class="lang-meta">Flask + sqlite3 stdlib &middot; Port 5001</span>
  </div>
  <p>ORMery is imported from vendor directories via <code>sys.path</code>. Value maps for inserts use <code>temper_core.Pair</code> and <code>map_constructor</code>.</p>

<pre><code>from ormery.ormery import schema, field, Query, InMemoryStore, to_insert_sql
from temper_core import Pair, map_constructor

store = InMemoryStore()

list_schema = schema("lists", [
    field("name", "String", False, False),
    field("created_at", "String", False, True),
])

todo_schema = schema("todos", [
    field("title", "String", False, False),
    field("completed", "Int", False, False),
    field("list_id", "Int", False, False),
    field("created_at", "String", False, True),
])</code></pre>

  <p><strong>SELECT</strong> &mdash; Chained query builder, snake_case API:</p>
<pre><code># Get todos for a list
sql = (Query(todo_schema, store)
    .where("list_id", "=", str(list_id))
    .order_by("completed", "asc")
    .order_by("created_at", "desc")
    .to_sql().to_string())
todos = conn.execute(sql).fetchall()</code></pre>

  <p><strong>INSERT</strong> &mdash; Build a Temper map from a Python dict:</p>
<pre><code>def _make_map(d):
    return map_constructor(tuple(Pair(k, v) for k, v in d.items()))

sql = to_insert_sql(list_schema, _make_map({"name": name})).to_string()
conn.execute(sql)</code></pre>
</div>

<!-- ═══════════════════════════ C# ═══════════════════════════ -->
<div class="lang-section">
  <div class="lang-header">
    <h3>C#</h3>
    <span class="lang-meta">ASP.NET Core + Microsoft.Data.Sqlite &middot; Port 5002</span>
  </div>
  <p>ORMery is referenced via <code>&lt;ProjectReference&gt;</code> to the vendored <code>Ormery.csproj</code>. Value maps use <code>Mapped.ConstructMap</code> with <code>Listed.CreateReadOnlyList</code>.</p>

<pre><code>using Ormery;
using TemperLang.Core;

public static readonly Schema ListSchema = OrmeryGlobal.Schema(
    "lists",
    Listed.CreateReadOnlyList&lt;Field&gt;(
        OrmeryGlobal.Field("name", "String", false, false),
        OrmeryGlobal.Field("created_at", "String", false, false)
    )
);

private static readonly InMemoryStore _dummyStore = new InMemoryStore();</code></pre>

  <p><strong>SELECT</strong> &mdash; PascalCase API, <code>.Where()</code> / <code>.OrderBy()</code>:</p>
<pre><code>// Get a list by ID
var query = new Query(ListSchema, _dummyStore)
    .Where("id", "=", id.ToString());
string sql = query.ToSql().ToString();

// Get todos ordered by completion status
var todoQuery = new Query(TodoSchema, _dummyStore)
    .Where("list_id", "=", listId.ToString())
    .OrderBy("completed", "asc")
    .OrderBy("created_at", "asc");
string todoSql = todoQuery.ToSql().ToString();</code></pre>

  <p><strong>INSERT</strong> &mdash; Build value map via Temper's core types:</p>
<pre><code>var values = Mapped.ConstructMap(
    Listed.CreateReadOnlyList&lt;KeyValuePair&lt;string, string&gt;&gt;(
        new KeyValuePair&lt;string, string&gt;("name", name),
        new KeyValuePair&lt;string, string&gt;("created_at", now)
    ));
string sql = OrmeryGlobal.ToInsertSql(ListSchema, values).ToString();</code></pre>
</div>

<!-- ═══════════════════════════ Rust ═══════════════════════════ -->
<div class="lang-section">
  <div class="lang-header">
    <h3>Rust</h3>
    <span class="lang-meta">Axum + rusqlite &middot; Port 5003</span>
  </div>
  <p>ORMery is a <code>path</code> dependency in Cargo.toml. Note the <code>r#where</code> syntax&mdash;<code>where</code> is a Rust reserved keyword.</p>

<pre><code>use ormery::{schema, field, Query, InMemoryStore, to_insert_sql, Field, Schema};
use std::sync::Arc;

fn build_list_schema() -&gt; Schema {
    let fields: Vec&lt;Field&gt; = vec![
        field("name", "String", false, false),
        field("created_at", "String", false, true),
    ];
    schema("lists", Arc::new(fields))
}</code></pre>

  <p><strong>SELECT</strong> &mdash; <code>.r#where()</code> escapes the keyword, <code>.to_sql()</code> returns a fragment:</p>
<pre><code>// Get todos for a list
let sql = Query::new(todo_schema.clone(), store.clone())
    .r#where("list_id", "=", list_id.to_string())
    .order_by("completed", "asc")
    .to_sql().to_string().to_string();
let mut stmt = conn.prepare(&amp;sql)?;</code></pre>

  <p><strong>INSERT</strong> &mdash; Build a <code>temper_core::Map</code> from owned strings:</p>
<pre><code>let values = temper_core::Map::new(&amp;[
    (Arc::new("name".to_string()), Arc::new(name.to_string())),
]);
let sql = to_insert_sql(list_schema.clone(), values)
    .to_string().to_string();
conn.execute(&amp;sql, [])?;</code></pre>
</div>

<!-- ═══════════════════════════ Java ═══════════════════════════ -->
<div class="lang-section">
  <div class="lang-header">
    <h3>Java</h3>
    <span class="lang-meta">Spring Boot + JDBC &middot; Port 5004</span>
  </div>
  <p>ORMery source is compiled as an additional Maven source directory via <code>build-helper-maven-plugin</code>. Standard Java camelCase API.</p>

<pre><code>import ormery.OrmeryGlobal;
import ormery.Query;
import ormery.Schema;
import ormery.InMemoryStore;

Schema listSchema = OrmeryGlobal.schema("lists", List.of(
    OrmeryGlobal.field("name", "String", false, false),
    OrmeryGlobal.field("created_at", "String", false, false)
));

InMemoryStore dummyStore = new InMemoryStore();</code></pre>

  <p><strong>SELECT</strong> &mdash; Fluent <code>.where()</code> / <code>.orderBy()</code> / <code>.toSql()</code>:</p>
<pre><code>// Find a list by ID
String sql = new Query(listSchema, dummyStore)
    .where("id", "=", String.valueOf(id))
    .limit(1)
    .toSql().toString();
List&lt;TodoList&gt; results = jdbc.query(sql, listMapper);</code></pre>

  <p><strong>INSERT</strong> &mdash; Pass a <code>Map&lt;String,String&gt;</code> to <code>toInsertSql</code>:</p>
<pre><code>Map&lt;String, String&gt; values = new LinkedHashMap&lt;&gt;();
values.put("name", name);
values.put("created_at", LocalDateTime.now().format(DT_FMT));

SqlFragment insertSql = OrmeryGlobal.toInsertSql(listSchema, values);
jdbc.execute(insertSql.toString());</code></pre>
</div>

<!-- ═══════════════════════════ Lua ═══════════════════════════ -->
<div class="lang-section">
  <div class="lang-header">
    <h3>Lua</h3>
    <span class="lang-meta">LuaSocket + lsqlite3 &middot; Port 5005</span>
  </div>
  <p>ORMery is loaded via <code>package.path</code> from vendor directories. Helper functions bridge Lua tables to Temper's map type.</p>

<pre><code>local temper = require("temper-core")
local ormery = require("ormery")

local lists_schema = ormery.schema("lists", temper.listof(
    ormery.field("name",       "String", false, false),
    ormery.field("created_at", "String", false, true)
))

local todos_schema = ormery.schema("todos", temper.listof(
    ormery.field("title",      "String", false, false),
    ormery.field("completed",  "Int",    false, false),
    ormery.field("list_id",    "Int",    false, false),
    ormery.field("created_at", "String", false, true)
))</code></pre>

  <p><strong>SELECT</strong> &mdash; Build query with options table, call <code>:toSql():toString()</code>:</p>
<pre><code>local q = ormery.Query(todos_schema, nil)
q:where("list_id", "=", tostring(list_id))
q:orderBy("completed", "asc")
q:orderBy("created_at", "desc")
local sql = q:toSql():toString()</code></pre>

  <p><strong>INSERT</strong> &mdash; Convert Lua table to Temper map:</p>
<pre><code>local function make_values(tbl)
    local pairs_list = {}
    for k, v in pairs(tbl) do
        pairs_list[#pairs_list + 1] = temper.pair_constructor(k, tostring(v))
    end
    return temper.map_constructor(pairs_list)
end

local vals = make_values({name = name})
local sql = ormery.toInsertSql(lists_schema, vals):toString()
conn:exec(sql)</code></pre>
</div>

<h2>API Comparison at a Glance</h2>

<h3>Schema Definition</h3>
<table>
  <thead><tr><th>Language</th><th>Code</th></tr></thead>
  <tbody>
    <tr><td>JS</td><td><code>schema("lists", [field("name", "String", false, false)])</code></td></tr>
    <tr><td>Python</td><td><code>schema("lists", [field("name", "String", False, False)])</code></td></tr>
    <tr><td>C#</td><td><code>OrmeryGlobal.Schema("lists", Listed.CreateReadOnlyList&lt;Field&gt;(...))</code></td></tr>
    <tr><td>Rust</td><td><code>schema("lists".to_string(), Arc::new(vec![field(...)]))</code></td></tr>
    <tr><td>Java</td><td><code>OrmeryGlobal.schema("lists", List.of(OrmeryGlobal.field(...)))</code></td></tr>
    <tr><td>Lua</td><td><code>ormery.schema("lists", temper.listof(ormery.field(...)))</code></td></tr>
  </tbody>
</table>

<h3>SELECT by ID</h3>
<table>
  <thead><tr><th>Language</th><th>Code</th></tr></thead>
  <tbody>
    <tr><td>JS</td><td><code>new Query(s, store).where("id", "=", String(id)).toSql().toString()</code></td></tr>
    <tr><td>Python</td><td><code>Query(s, store).where("id", "=", str(id)).to_sql().to_string()</code></td></tr>
    <tr><td>C#</td><td><code>new Query(s, store).Where("id", "=", id.ToString()).ToSql().ToString()</code></td></tr>
    <tr><td>Rust</td><td><code>Query::new(s, store).r#where("id", "=", id.to_string()).to_sql()</code></td></tr>
    <tr><td>Java</td><td><code>new Query(s, store).where("id", "=", String.valueOf(id)).toSql()</code></td></tr>
    <tr><td>Lua</td><td><code>ormery.Query(s, nil):where("id", "=", tostring(id)):toSql():toString()</code></td></tr>
  </tbody>
</table>

<h3>INSERT</h3>
<table>
  <thead><tr><th>Language</th><th>Value Map Construction</th></tr></thead>
  <tbody>
    <tr><td>JS</td><td><code>new Map([["name", name]])</code></td></tr>
    <tr><td>Python</td><td><code>map_constructor(tuple(Pair(k, v) for k, v in d.items()))</code></td></tr>
    <tr><td>C#</td><td><code>Mapped.ConstructMap(Listed.CreateReadOnlyList&lt;KVP&gt;(...))</code></td></tr>
    <tr><td>Rust</td><td><code>temper_core::Map::new(&amp;[(Arc::new(k), Arc::new(v))])</code></td></tr>
    <tr><td>Java</td><td><code>new LinkedHashMap&lt;&gt;() {{ put("name", name); }}</code></td></tr>
    <tr><td>Lua</td><td><code>temper.map_constructor({temper.pair_constructor(k, v)})</code></td></tr>
  </tbody>
</table>

<h3>What ORMery Handles vs. Raw SQL</h3>
<table class="summary-table">
  <thead>
    <tr><th>Operation</th><th>ORMery?</th><th>Notes</th></tr>
  </thead>
  <tbody>
    <tr><td>SELECT</td><td>Yes</td><td><code>.where()</code>, <code>.orderBy()</code>, <code>.limit()</code>, <code>.select()</code></td></tr>
    <tr><td>INSERT</td><td>Yes</td><td><code>toInsertSql(schema, values)</code> with autoescaped values</td></tr>
    <tr><td>UPDATE</td><td>No</td><td>Raw parameterized SQL or <code>SqlBuilder</code></td></tr>
    <tr><td>DELETE</td><td>No</td><td>Raw parameterized SQL or <code>SqlBuilder</code></td></tr>
    <tr><td>CREATE TABLE</td><td>No</td><td>Raw DDL</td></tr>
    <tr><td>JOINs / Aggregates</td><td>No</td><td>Raw SQL (COUNT, SUM, LEFT JOIN)</td></tr>
  </tbody>
</table>

<h2>End-to-End Pipeline</h2>

<p>A single push to the ormery repo triggers a fully automated pipeline that compiles Temper, distributes the compiled output to six library repos, and updates six demo app repos&mdash;all without manual intervention.</p>

<h3>The Three Tiers</h3>

<p><span class="step-num">1</span> <strong>Push to ormery</strong> &mdash; Any commit to <code>main</code> triggers <code>publish-libs.yml</code>.</p>

<p><span class="step-num">2</span> <strong>Build &amp; distribute</strong> &mdash; The workflow clones the Temper compiler, builds it (JDK 21 + Gradle), runs <code>temper build</code> to produce <code>temper.out/{js,py,csharp,rust,java,lua}/</code>. Then six parallel matrix jobs push the compiled output to the corresponding lib repos via SSH deploy keys.</p>

<p><span class="step-num">3</span> <strong>Update apps</strong> &mdash; Each lib repo has a <code>notify-app.yml</code> workflow. When the lib repo receives a push, it clones the corresponding app repo, replaces the <code>vendor/{ormery,std,temper-core}/</code> directories with the latest compiled output, commits, and pushes.</p>

<div class="pipeline-diagram">
  ormery repo (push to main)
    |
    v
  publish-libs.yml
    |
    +-- temper build (JDK 21 + Gradle)
    |       produces temper.out/{js,py,csharp,rust,java,lua}/
    |
    +-- 6 parallel matrix jobs
            |
            +--&gt; ormery-js       ──notify-app.yml──&gt; ormery-js-app/vendor/
            +--&gt; ormery-py       ──notify-app.yml──&gt; ormery-py-app/vendor/
            +--&gt; ormery-csharp   ──notify-app.yml──&gt; ormery-csharp-app/TodoApp/vendor/
            +--&gt; ormery-rust     ──notify-app.yml──&gt; ormery-rust-app/vendor/
            +--&gt; ormery-java     ──notify-app.yml──&gt; ormery-java-app/vendor/
            +--&gt; ormery-lua      ──notify-app.yml──&gt; ormery-lua-app/vendor/

  Result: 12 repos updated from a single push</div>

<h3>How Vendoring Works</h3>

<p>Each lib repo contains the full compiled tree: <code>ormery/</code>, <code>std/</code>, and <code>temper-core/</code>. Each app repo vendors these three directories and references them through the language's native dependency mechanism:</p>

<table>
  <thead><tr><th>Language</th><th>Vendor Reference</th></tr></thead>
  <tbody>
    <tr><td>JS</td><td><code>"ormery": "file:./vendor/ormery"</code> in package.json (ESM)</td></tr>
    <tr><td>Python</td><td><code>sys.path.insert(0, "vendor/ormery")</code> in app.py</td></tr>
    <tr><td>C#</td><td><code>&lt;ProjectReference Include="vendor/ormery/src/Ormery.csproj" /&gt;</code></td></tr>
    <tr><td>Rust</td><td><code>ormery = { path = "vendor/ormery" }</code> in Cargo.toml</td></tr>
    <tr><td>Java</td><td><code>build-helper-maven-plugin</code> adds <code>vendor/ormery/src/main/java</code> as source</td></tr>
    <tr><td>Lua</td><td><code>package.path = "vendor/ormery/?.lua;" .. package.path</code></td></tr>
  </tbody>
</table>

<h3>Authentication</h3>

<p>Cross-repo pushes use <strong>SSH deploy keys</strong> (not PATs). Each target repo has a deploy key with write access. The private keys are stored as GitHub Actions secrets:</p>

<ul>
  <li><strong>ormery repo:</strong> <code>DEPLOY_KEY_{JS,PY,CSHARP,RUST,JAVA,LUA}</code> &rarr; push to lib repos</li>
  <li><strong>lib repos:</strong> <code>DEPLOY_KEY_APP</code> &rarr; push to app repos</li>
</ul>

<h3>Workflow Details</h3>

<p><strong><code>publish-libs.yml</code></strong> (on ormery) &mdash; Triggered on push to <code>main</code>. Builds Temper, produces compiled output, syncs to six lib repos. Also writes the <code>notify-app.yml</code> workflow into each lib repo with the correct app repo name and vendor path substituted from a template.</p>

<p><strong><code>notify-app.yml</code></strong> (on each lib repo) &mdash; Triggered when the lib repo receives a push. Clones the corresponding app repo, replaces <code>vendor/{ormery,std,temper-core}/</code> with the latest compiled output, commits, and pushes.</p>

<h2>Demo Apps</h2>

<p>Each app is a todo list manager with lists and todos, styled to look like Mac System 6 with Windows 95 windows. Same features, same schema, six different stacks.</p>

<table>
  <thead>
    <tr><th>Language</th><th>Web Framework</th><th>DB Driver</th><th>Port</th><th>Repo</th></tr>
  </thead>
  <tbody>
    <tr><td>JavaScript</td><td>Express + EJS</td><td>ORMery + better-sqlite3</td><td>5006</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-js-app">ormery-js-app</a></td></tr>
    <tr><td>Python</td><td>Flask + Jinja2</td><td>ORMery + sqlite3</td><td>5001</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-py-app">ormery-py-app</a></td></tr>
    <tr><td>C#</td><td>ASP.NET Core Razor</td><td>ORMery + Microsoft.Data.Sqlite</td><td>5002</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-csharp-app">ormery-csharp-app</a></td></tr>
    <tr><td>Rust</td><td>Axum + Askama</td><td>ORMery + rusqlite</td><td>5003</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-rust-app">ormery-rust-app</a></td></tr>
    <tr><td>Java</td><td>Spring Boot + Thymeleaf</td><td>ORMery + JDBC</td><td>5004</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-java-app">ormery-java-app</a></td></tr>
    <tr><td>Lua</td><td>LuaSocket (hand-rolled)</td><td>ORMery + lsqlite3</td><td>5005</td><td><a href="https://github.com/notactuallytreyanastasio/ormery-lua-app">ormery-lua-app</a></td></tr>
  </tbody>
</table>

<h2>Repositories</h2>

<h3>Compiled Libraries</h3>
<p>Automatically updated by the pipeline. Each contains the full compiled Temper tree.</p>
<table>
  <thead><tr><th>Repo</th><th>Language</th></tr></thead>
  <tbody>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-js">ormery-js</a></td><td>JavaScript</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-py">ormery-py</a></td><td>Python</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-csharp">ormery-csharp</a></td><td>C#</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-rust">ormery-rust</a></td><td>Rust</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-java">ormery-java</a></td><td>Java</td></tr>
    <tr><td><a href="https://github.com/notactuallytreyanastasio/ormery-lua">ormery-lua</a></td><td>Lua</td></tr>
  </tbody>
</table>

<footer>
  <p>
    Built with <a href="https://github.com/temperlang/temper">Temper</a> &middot;
    SQL injection protection via contextual autoescaping &middot;
    Decision tracking via <a href="https://github.com/notactuallytreyanastasio/deciduous">Deciduous</a> &middot;
    Source: <a href="https://github.com/notactuallytreyanastasio/ormery">ormery</a>
  </p>
</footer>

</div>
</body>
</html>
